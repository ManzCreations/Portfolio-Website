<!-- Deployment ID: AKfycbxUULLe9sRmSRG7wvewTPgwKYBXd9yxhqQKKzT_XgeF2IPyJKPQ_HWEJduwu1bW81E8mw -->
<!-- Web app url: https://script.google.com/macros/s/AKfycbxUULLe9sRmSRG7wvewTPgwKYBXd9yxhqQKKzT_XgeF2IPyJKPQ_HWEJduwu1bW81E8mw/exec -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recipe Manager - Steven Manz</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://kit.fontawesome.com/cd7909d44e.js" crossorigin="anonymous"></script>
    <style>
        #header {
            background-image: none !important;
            background-color: var(--main-background-color, #fff) !important;
            height: auto !important;
            min-height: 20vh !important;
        }

        /* Override mobile background image too */
        @media only screen and (max-width: 600px) {
            #header {
                background-image: none !important;
            }
        }

        /* Recipe-specific styles */
        .recipe-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .recipe-header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 0;
        }

        .recipe-header h1 {
            font-size: 48px;
            color: var(--primary-color, #00d5ff);
            margin-bottom: 20px;
        }

        .recipe-header p {
            font-size: 18px;
            color: var(--text-color, #333);
            max-width: 600px;
            margin: 0 auto;
        }

        .recipe-controls {
            background: var(--about-me-background-color, #f8f9fa);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 40px;
            box-shadow: 0 4px 15px rgba(0, 213, 255, 0.1);
        }

        .url-input-section {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .url-input {
            flex: 1;
            min-width: 300px;
            padding: 15px 20px;
            border: 2px solid var(--secondary-color, #007bb5);
            border-radius: 8px;
            background: var(--main-background-color, #fff);
            color: var(--text-color, #333);
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .url-input:focus {
            border-color: var(--primary-color, #00d5ff);
        }

        .add-recipe-btn {
            padding: 15px 30px;
            background: var(--primary-color, #00d5ff);
            color: var(--main-background-color, #fff);
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 150px;
        }

        .add-recipe-btn:hover {
            background: var(--secondary-color, #007bb5);
            transform: translateY(-2px);
        }

        .add-recipe-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Debug Panel Styles */
        .debug-panel {
            background: #1e1e1e;
            color: #ffffff;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid #444;
            overflow: hidden;
        }

        .debug-header {
            background: #2d2d2d;
            padding: 15px 20px;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .debug-title {
            font-weight: bold;
            color: #00d5ff;
        }

        .debug-toggle {
            background: #007bb5;
            color: white;
            border: none;
            padding: 5px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .debug-content {
            padding: 15px 20px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .debug-log {
            margin: 5px 0;
            padding: 5px 0;
        }

        .debug-log.success {
            color: #4CAF50;
        }

        .debug-log.warning {
            color: #FF9800;
        }

        .debug-log.error {
            color: #f44336;
        }

        .debug-log.info {
            color: #2196F3;
        }

        .debug-timestamp {
            color: #888;
            font-size: 11px;
        }

        .debug-data {
            background: #2d2d2d;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 3px solid #00d5ff;
        }

        .debug-step {
            background: #2a2a2a;
            padding: 8px 12px;
            margin: 8px 0;
            border-radius: 5px;
            border-left: 3px solid #4CAF50;
        }

        .debug-step.failed {
            border-left-color: #f44336;
        }

        .extraction-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
            padding: 15px;
            background: #2d2d2d;
            border-radius: 8px;
        }

        .stat-item {
            text-align: center;
            padding: 10px;
            background: #3d3d3d;
            border-radius: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #00d5ff;
        }

        .stat-label {
            font-size: 12px;
            color: #ccc;
        }

        .recipe-grid {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 30px;
        }

        .recipe-card {
            background: var(--services-background-color, #f8f9fa);
            border-radius: 12px;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
            display: flex;
            align-items: center;
            padding: 15px;
            min-height: 100px;
            box-shadow: 0 2px 8px rgba(0, 213, 255, 0.1);
        }

        .recipe-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 213, 255, 0.2);
        }

        .recipe-card img {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 8px;
            background: var(--portfolio-background-color, #eee);
            flex-shrink: 0;
            margin-right: 20px;
        }

        .recipe-card-content {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-width: 0; /* Allows text to truncate */
        }

        .recipe-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--primary-color, #00d5ff);
            margin: 0 0 8px 0;
            line-height: 1.3;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .recipe-meta {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 5px;
            font-size: 13px;
            color: #999;
            flex-wrap: wrap;
        }

        .recipe-description {
            font-size: 13px;
            color: var(--text-color, #666);
            line-height: 1.4;
            margin: 0;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            max-width: 100%;
        }

        .recipe-actions {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-shrink: 0;
        }

        .recipe-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .delete-btn {
            background: #ff4757;
            color: white;
        }

        .delete-btn:hover {
            background: #ff3742;
            transform: scale(1.1);
        }

        .view-btn, .delete-btn {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .view-btn {
            background: var(--primary-color, #00d5ff);
            color: var(--main-background-color, #fff);
        }

        .view-btn:hover {
            background: var(--secondary-color, #007bb5);
            transform: scale(1.1);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            background-color: var(--main-background-color, #fff);
            margin: 2% auto;
            padding: 0;
            border-radius: 15px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            animation: slideIn 0.3s ease;
        }

        .modal-header {
            background: var(--primary-color, #00d5ff);
            color: var(--main-background-color, #fff);
            padding: 20px 30px;
            border-radius: 15px 15px 0 0;
            position: relative;
        }

        .modal-title {
            font-size: 24px;
            font-weight: 600;
            margin: 0;
            padding-right: 40px;
        }

        .close {
            position: absolute;
            right: 20px;
            top: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: var(--main-background-color, #fff);
            transition: opacity 0.3s ease;
        }

        .close:hover {
            opacity: 0.7;
        }

        .modal-body {
            padding: 30px;
        }

        .recipe-info {
            flex: 1;
            min-width: 0;
            margin-right: 15px;
        }

        .ingredients-section, .instructions-section {
            background: var(--about-me-background-color, #f8f9fa);
            padding: 25px;
            border-radius: 10px;
        }

        .section-title {
            font-size: 20px;
            color: var(--primary-color, #00d5ff);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ingredients-list {
            list-style: none;
            padding: 0;
        }

        .ingredients-list li {
            padding: 8px 0;
            border-bottom: 1px solid var(--services-background-color, #f8f9fa);
            color: var(--text-color, #333);
            position: relative;
            padding-left: 20px;
        }

        .ingredients-list li:before {
            content: "•";
            color: var(--primary-color, #00d5ff);
            position: absolute;
            left: 0;
            font-weight: bold;
        }

        .instructions-list {
            counter-reset: step-counter;
            list-style: none;
            padding: 0;
        }

        .instructions-list li {
            counter-increment: step-counter;
            margin-bottom: 15px;
            padding: 15px;
            background: var(--services-background-color, #f8f9fa);
            border-radius: 8px;
            color: var(--text-color, #333);
            position: relative;
            padding-left: 50px;
        }

        .instructions-list li:before {
            content: counter(step-counter);
            position: absolute;
            left: 15px;
            top: 15px;
            background: var(--primary-color, #00d5ff);
            color: var(--main-background-color, #fff);
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: var(--primary-color, #00d5ff);
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--secondary-color, #007bb5);
            border-top: 2px solid var(--primary-color, #00d5ff);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .error-message {
            background: #ff4757;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
        }

        .success-message {
            background: #2ed573;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--secondary-color, #007bb5);
            grid-column: 1 / -1; /* Span full width when grid is used */
        }

        .empty-state i {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(-30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive design */
        @media only screen and (max-width: 768px) {
            /* .recipe-info {
                grid-template-columns: 1fr;
            } */
            
            .url-input-section {
                flex-direction: column;
            }
            
            .modal-content {
                margin: 5% auto;
                width: 95%;
            }
            
            .modal-body {
                padding: 20px;
            }

            .extraction-stats {
                grid-template-columns: 1fr;
            }

            .debug-content {
                font-size: 10px;
            }
        }

        @media only screen and (max-width: 768px) {
            .recipe-card {
                padding: 12px;
                min-height: 80px;
            }
            
            .recipe-card img {
                width: 60px;
                height: 60px;
                margin-right: 15px;
            }
            
            .recipe-title {
                font-size: 16px;
            }
            
            .recipe-meta {
                font-size: 12px;
                gap: 10px;
            }
            
            .recipe-description {
                font-size: 12px;
                -webkit-line-clamp: 1;
            }
            
            .recipe-actions {
                gap: 6px;
            }
            
            .view-btn, .delete-btn {
                width: 32px;
                height: 32px;
                font-size: 12px;
            }
        }

        @media only screen and (max-width: 480px) {
            .recipe-card {
                flex-direction: column;
                text-align: center;
                padding: 15px;
            }
            
            .recipe-card img {
                margin: 0 0 10px 0;
                width: 60px;
                height: 60px;
            }
            
            .recipe-card-content {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }
            
            .recipe-info {
                margin-right: 0;
                text-align: center;
            }
            
            .recipe-title {
                white-space: normal;
                text-overflow: unset;
                overflow: visible;
            }
        }

        /* Password Modal Styles */
        .password-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            animation: fadeIn 0.3s ease;
        }

        .password-modal-content {
            background-color: var(--main-background-color, #fff);
            margin: 10% auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            text-align: center;
            position: relative;
            animation: slideIn 0.3s ease;
        }

        .password-modal h2 {
            color: var(--primary-color, #00d5ff);
            margin-bottom: 20px;
        }

        .password-modal p {
            margin-bottom: 25px;
            color: var(--text-color, #333);
            line-height: 1.6;
        }

        .password-input {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid var(--secondary-color, #007bb5);
            border-radius: 8px;
            background: var(--main-background-color, #fff);
            color: var(--text-color, #333);
            font-size: 16px;
            outline: none;
            margin-bottom: 20px;
            transition: border-color 0.3s ease;
            box-sizing: border-box;
        }

        .password-input:focus {
            border-color: var(--primary-color, #00d5ff);
        }

        .password-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .login-btn, .skip-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .login-btn {
            background: var(--primary-color, #00d5ff);
            color: var(--main-background-color, #fff);
        }

        .login-btn:hover {
            background: var(--secondary-color, #007bb5);
            transform: translateY(-2px);
        }

        .skip-btn {
            background: #6c757d;
            color: white;
        }

        .skip-btn:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .password-status {
            background: var(--about-me-background-color, #f8f9fa);
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 213, 255, 0.1);
        }

        .password-status span {
            color: var(--text-color, #333);
            font-weight: 500;
        }

        .logout-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: background 0.3s ease;
        }

        .logout-btn:hover {
            background: #c82333;
        }

        @media only screen and (max-width: 768px) {
            .password-buttons {
                flex-direction: column;
            }
            
            .password-status {
                flex-direction: column;
                gap: 10px;
                text-align: center;
            }
        }

        /* Edit Mode Styles */
        .edit-mode-header {
            background: #ff9800;
            color: white;
            padding: 15px 30px;
            margin: -30px -30px 20px -30px;
            border-radius: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .edit-mode-title {
            font-size: 16px;
            font-weight: 600;
            margin: 0;
        }

        .edit-actions {
            display: flex;
            gap: 10px;
        }

        .save-btn, .cancel-btn {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .save-btn {
            background: #4CAF50;
            color: white;
        }

        .save-btn:hover {
            background: #45a049;
        }

        .cancel-btn {
            background: #f44336;
            color: white;
        }

        .cancel-btn:hover {
            background: #da190b;
        }

        .edit-btn {
            background: #ff9800;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-left: 10px;
        }

        .edit-btn:hover {
            background: #e68900;
        }

        /* Editable Lists */
        .editable-list {
            list-style: none;
            padding: 0;
        }

        .editable-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: var(--services-background-color, #f8f9fa);
            border-radius: 8px;
            border: 2px solid transparent;
            transition: border-color 0.3s ease;
        }

        .editable-item:hover {
            border-color: var(--primary-color, #00d5ff);
        }

        .editable-input, .editable-textarea {
            flex: 1;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 8px 12px;
            font-size: 14px;
            line-height: 1.4;
            background: white;
            transition: border-color 0.3s ease;
        }

        .editable-input:focus, .editable-textarea:focus {
            outline: none;
            border-color: var(--primary-color, #00d5ff);
        }

        .editable-textarea {
            min-height: 60px;
            resize: vertical;
        }

        .item-controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .move-btn, .remove-btn {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .move-btn {
            background: #007bb5;
            color: white;
        }

        .move-btn:hover {
            background: #005c8a;
        }

        .remove-btn {
            background: #ff4757;
            color: white;
        }

        .remove-btn:hover {
            background: #ff3742;
        }

        .add-item-section {
            margin-top: 15px;
            padding: 15px;
            background: var(--about-me-background-color, #f8f9fa);
            border-radius: 8px;
            border: 2px dashed var(--secondary-color, #007bb5);
        }

        .add-item-btn {
            background: var(--primary-color, #00d5ff);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .add-item-btn:hover {
            background: var(--secondary-color, #007bb5);
            transform: translateY(-1px);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .saving-indicator {
            display: none;
            background: #4CAF50;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 2000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .saving-indicator.show {
            display: block;
            animation: slideInRight 0.3s ease;
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Create Recipe Button */
        .create-recipe-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 15px;
            min-width: 150px;
        }

        .create-recipe-btn:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .create-recipe-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Create Recipe Modal */
        .create-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            animation: fadeIn 0.3s ease;
            overflow-y: auto;
        }

        .create-modal-content {
            background-color: var(--main-background-color, #fff);
            margin: 20px auto;
            padding: 0;
            border-radius: 15px;
            width: 95%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            animation: slideIn 0.3s ease;
        }

        .create-modal-header {
            background: #4CAF50;
            color: white;
            padding: 20px 30px;
            border-radius: 15px 15px 0 0;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .create-modal-title {
            font-size: 24px;
            font-weight: 600;
            margin: 0;
            padding-right: 40px;
        }

        .create-close {
            position: absolute;
            right: 20px;
            top: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: white;
            transition: opacity 0.3s ease;
        }

        .create-close:hover {
            opacity: 0.7;
        }

        .create-modal-body {
            padding: 30px;
        }

        /* Form Styles */
        .form-group {
            margin-bottom: 25px;
        }

        .form-label {
            display: block;
            font-weight: 600;
            color: var(--primary-color, #00d5ff);
            margin-bottom: 8px;
            font-size: 16px;
        }

        .form-input, .form-textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            background: white;
            transition: border-color 0.3s ease;
            box-sizing: border-box;
            color: #333;
        }

        .form-input:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--primary-color, #00d5ff);
        }

        .form-textarea {
            min-height: 80px;
            resize: vertical;
            font-family: inherit;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        /* Dynamic Lists */
        .dynamic-list {
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 15px;
            min-height: 100px;
        }

        .dynamic-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 15px;
            padding: 15px;
            background: var(--about-me-background-color, #f8f9fa);
            border-radius: 8px;
            border: 2px solid transparent;
            transition: border-color 0.3s ease;
        }

        .dynamic-item:hover {
            border-color: var(--primary-color, #00d5ff);
        }

        .dynamic-item-number {
            background: var(--primary-color, #00d5ff);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
            margin-top: 8px;
        }

        .dynamic-input, .dynamic-textarea {
            flex: 1;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            font-size: 14px;
            background: white;
            transition: border-color 0.3s ease;
            color: #333;
        }

        .dynamic-input:focus, .dynamic-textarea:focus {
            outline: none;
            border-color: var(--primary-color, #00d5ff);
        }

        .dynamic-textarea {
            min-height: 60px;
            resize: vertical;
        }

        .dynamic-controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .dynamic-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .move-up-btn, .move-down-btn {
            background: #007bb5;
            color: white;
        }

        .move-up-btn:hover, .move-down-btn:hover {
            background: #005c8a;
        }

        .remove-item-btn {
            background: #ff4757;
            color: white;
        }

        .remove-item-btn:hover {
            background: #ff3742;
        }

        .add-dynamic-btn {
            background: var(--primary-color, #00d5ff);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-top: 10px;
            width: 100%;
        }

        .add-dynamic-btn:hover {
            background: var(--secondary-color, #007bb5);
        }

        /* Action Buttons */
        .create-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        .save-recipe-btn, .cancel-create-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 140px;
        }

        .save-recipe-btn {
            background: #4CAF50;
            color: white;
        }

        .save-recipe-btn:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .cancel-create-btn {
            background: #6c757d;
            color: white;
        }

        .cancel-create-btn:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        /* Mobile Optimizations */
        @media only screen and (max-width: 768px) {
            .create-modal-content {
                margin: 10px;
                width: calc(100% - 20px);
                max-height: 95vh;
            }
            
            .create-modal-body {
                padding: 20px;
            }
            
            .form-row {
                grid-template-columns: 1fr;
            }
            
            .dynamic-item {
                padding: 12px;
            }
            
            .dynamic-controls {
                flex-direction: row;
                gap: 5px;
            }
            
            .dynamic-btn {
                width: 28px;
                height: 28px;
            }
            
            .create-actions {
                flex-direction: column;
            }
            
            .save-recipe-btn, .cancel-create-btn {
                min-width: unset;
                width: 100%;
            }
            
            .url-input-section {
                flex-direction: column;
            }
            
            .create-recipe-btn {
                margin-left: 0;
                margin-top: 15px;
                width: 100%;
            }
        }

        @media only screen and (max-width: 480px) {
            .create-modal-title {
                font-size: 20px;
            }
            
            .form-input, .form-textarea {
                font-size: 16px; /* Prevents zoom on iOS */
                color: #333;
            }
            
            .dynamic-input, .dynamic-textarea {
                font-size: 14px;
                color: #333;
            }
            
            .dynamic-item {
                flex-direction: column;
                gap: 10px;
            }
            
            .dynamic-controls {
                flex-direction: row;
                justify-content: center;
            }
        }

        /* Shopping List Button */
        .shopping-list-btn {
            background: #9c27b0;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 15px;
            min-width: 150px;
        }

        .shopping-list-btn:hover {
            background: #7b1fa2;
            transform: translateY(-2px);
        }

        /* Recipe Selection Modal */
        .recipe-selection-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            overflow-y: auto;
        }

        .recipe-selection-content {
            background-color: var(--main-background-color, #fff);
            margin: 20px auto;
            padding: 0;
            border-radius: 15px;
            width: 95%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .recipe-selection-header {
            background: #9c27b0;
            color: white;
            padding: 20px 30px;
            border-radius: 15px 15px 0 0;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .recipe-selection-title {
            font-size: 24px;
            font-weight: 600;
            margin: 0;
            padding-right: 40px;
        }

        .recipe-selection-body {
            padding: 30px;
        }

        .recipe-checkbox-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: var(--about-me-background-color, #f8f9fa);
            border-radius: 10px;
            margin-bottom: 15px;
            border: 2px solid transparent;
            transition: border-color 0.3s ease;
        }

        .recipe-checkbox-item:hover {
            border-color: #9c27b0;
        }

        .recipe-checkbox-item.selected {
            border-color: #9c27b0;
            background: #f3e5f5;
        }

        .recipe-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .recipe-info-select {
            flex: 1;
            min-width: 0;
        }

        .recipe-title-select {
            font-size: 16px;
            font-weight: 600;
            color: var(--primary-color, #00d5ff);
            margin-bottom: 5px;
        }

        .recipe-meta-select {
            font-size: 12px;
            color: #999;
        }

        .quantity-input {
            width: 80px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            text-align: center;
            font-size: 14px;
            color: #333;
        }

        .quantity-label {
            font-size: 12px;
            color: #999;
            margin-left: 5px;
        }

        /* Shopping List Modal */
        .shopping-list-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            overflow-y: auto;
        }

        .shopping-list-content {
            background-color: var(--main-background-color, #fff);
            margin: 20px auto;
            padding: 0;
            border-radius: 15px;
            width: 95%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .shopping-list-header {
            background: #9c27b0;
            color: white;
            padding: 20px 30px;
            border-radius: 15px 15px 0 0;
            position: sticky;
            top: 0;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .shopping-list-title {
            font-size: 24px;
            font-weight: 600;
            margin: 0;
        }

        .shopping-list-actions {
            display: flex;
            gap: 10px;
        }

        .add-more-btn, .clear-list-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .add-more-btn:hover, .clear-list-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .shopping-list-body {
            padding: 30px;
        }

        .shopping-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px;
            background: var(--about-me-background-color, #f8f9fa);
            border-radius: 8px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .shopping-item.checked {
            opacity: 0.6;
            text-decoration: line-through;
            background: #666;
        }

        .shopping-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .shopping-item-text {
            flex: 1;
            font-size: 14px;
            color: white;
        }

        .remove-item-btn {
            background: #ff4757;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .remove-item-btn:hover {
            background: #ff3742;
        }

        .shopping-stats {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 14px;
            color: #444;
        }

        .generation-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .generate-list-btn, .cancel-selection-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .generate-list-btn {
            background: #9c27b0;
            color: white;
        }

        .generate-list-btn:hover {
            background: #7b1fa2;
        }

        .cancel-selection-btn {
            background: #6c757d;
            color: white;
        }

        .cancel-selection-btn:hover {
            background: #5a6268;
        }

        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
        }

        .close-btn:hover {
            opacity: 0.7;
        }

        /* Mobile Responsive */
        @media only screen and (max-width: 768px) {
            .shopping-list-btn {
                margin-left: 0;
                margin-top: 15px;
                width: 100%;
            }
            
            .recipe-selection-content,
            .shopping-list-content {
                margin: 10px;
                width: calc(100% - 20px);
            }
            
            .recipe-selection-body,
            .shopping-list-body {
                padding: 20px;
            }
            
            .shopping-list-header {
                flex-direction: column;
                gap: 15px;
                align-items: flex-start;
            }
            
            .shopping-list-actions {
                width: 100%;
                justify-content: space-between;
            }
            
            .recipe-checkbox-item {
                flex-wrap: wrap;
            }
            
            .quantity-input {
                width: 60px;
            }
        }
    </style>
</head>
<body>
    <div id="header" style="height: auto; min-height: 20vh; background-attachment: scroll;">
        <div class="container">
            <nav>
                <ul id="sidemenu">
                    <li><a href="index.html">Home</a></li>
                    <li><a href="index.html#about">About</a></li>
                    <li><a href="index.html#services">Services</a></li>
                    <li><a href="index.html#portfolio">Portfolio</a></li>
                    <li><a href="index.html#contact">Contact</a></li>
                    <li><a href="recipes.html" class="active">Recipes</a></li>
                    <i class="fas fa-times" onclick="closemenu()"></i>
                </ul>
                <i class="fas fa-bars" onclick="openmenu()"></i>
            </nav>
        </div>
    </div>

    <!-- Password Modal -->
    <div id="passwordModal" class="password-modal">
        <div class="password-modal-content">
            <h2><i class="fas fa-lock"></i> Recipe Manager Access</h2>
            <p>Enter a password to save your recipes to the cloud, or skip to use session-only mode (recipes won't be saved when you close the browser).</p>
            
            <input type="password" id="passwordInput" class="password-input" placeholder="Enter your password" maxlength="50">
            
            <div class="password-buttons">
                <button id="loginBtn" class="login-btn">
                    <i class="fas fa-sign-in-alt"></i> Login & Save to Cloud
                </button>
                <button id="skipPasswordBtn" class="skip-btn">
                    <i class="fas fa-clock"></i> Session Only
                </button>
            </div>
            
            <p style="font-size: 12px; margin-top: 20px; color: #666;">
                Your password creates a private space for your recipes. Choose any password you'll remember.
            </p>
        </div>
    </div>

    <div class="recipe-container">
        <div class="recipe-header">
            <h1><i class="fas fa-utensils"></i> Recipe Manager</h1>
            <p>Add, organize, and manage your favorite dinner recipes. Simply paste a recipe URL to automatically extract ingredients and cooking instructions.</p>
        </div>

        <div id="currentPassword" class="password-status" style="display: none;"></div>

        <div class="url-input-section">
            <input type="url" id="recipeUrl" class="url-input" placeholder="Paste recipe URL here (e.g., https://allrecipes.com/recipe/...)">
            <button id="addRecipeBtn" class="add-recipe-btn">
                <i class="fas fa-plus"></i> Add Recipe
            </button>
            <button id="createRecipeBtn" class="create-recipe-btn">
                <i class="fas fa-edit"></i> Create Recipe
            </button>
            <button id="shoppingListBtn" class="shopping-list-btn">
                <i class="fas fa-shopping-cart"></i> Shopping List
            </button>
        </div>

        <div id="recipesContainer">
            <div id="loadingRecipes" class="loading" style="display: none;">
                <div class="spinner"></div>
                <span>Loading recipes...</span>
            </div>
            <div id="recipeGrid" class="recipe-grid"></div>
        </div>
    </div>

    <!-- Recipe Modal -->
    <div id="recipeModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle" class="modal-title"></h2>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Recipe content will be loaded here -->
            </div>
        </div>
    </div>

    <div id="createRecipeModal" class="create-modal">
        <div class="create-modal-content">
            <div class="create-modal-header">
                <h2 class="create-modal-title">
                    <i class="fas fa-plus-circle"></i> Create New Recipe
                </h2>
                <span class="create-close">&times;</span>
            </div>
            <div class="create-modal-body">
                <form id="createRecipeForm">
                    <!-- Basic Info -->
                    <div class="form-group">
                        <label class="form-label" for="recipeTitle">
                            <i class="fas fa-heading"></i> Recipe Title *
                        </label>
                        <input type="text" id="recipeTitle" class="form-input" placeholder="Enter recipe title" required>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="recipeDescription">
                            <i class="fas fa-align-left"></i> Description
                        </label>
                        <textarea id="recipeDescription" class="form-textarea" placeholder="Brief description of your recipe"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="recipeImage">
                            <i class="fas fa-image"></i> Image URL (Optional)
                        </label>
                        <input type="url" id="recipeImage" class="form-input" placeholder="https://example.com/image.jpg">
                    </div>
                    
                    <!-- Time and Servings -->
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label" for="recipePrepTime">
                                <i class="fas fa-clock"></i> Prep Time
                            </label>
                            <input type="text" id="recipePrepTime" class="form-input" placeholder="e.g., 15m">
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="recipeCookTime">
                                <i class="fas fa-fire"></i> Cook Time
                            </label>
                            <input type="text" id="recipeCookTime" class="form-input" placeholder="e.g., 30m">
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label" for="recipeTotalTime">
                                <i class="fas fa-hourglass-half"></i> Total Time
                            </label>
                            <input type="text" id="recipeTotalTime" class="form-input" placeholder="e.g., 45m">
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="recipeServings">
                                <i class="fas fa-users"></i> Servings
                            </label>
                            <input type="text" id="recipeServings" class="form-input" placeholder="e.g., 4">
                        </div>
                    </div>
                    
                    <!-- Ingredients -->
                    <div class="form-group">
                        <label class="form-label">
                            <i class="fas fa-list"></i> Ingredients *
                        </label>
                        <div id="ingredientsList" class="dynamic-list">
                            <!-- Ingredients will be added dynamically -->
                        </div>
                        <button type="button" onclick="addIngredientField()" class="add-dynamic-btn">
                            <i class="fas fa-plus"></i> Add Ingredient
                        </button>
                    </div>
                    
                    <!-- Instructions -->
                    <div class="form-group">
                        <label class="form-label">
                            <i class="fas fa-clipboard-list"></i> Instructions *
                        </label>
                        <div id="instructionsList" class="dynamic-list">
                            <!-- Instructions will be added dynamically -->
                        </div>
                        <button type="button" onclick="addInstructionField()" class="add-dynamic-btn">
                            <i class="fas fa-plus"></i> Add Instruction
                        </button>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div class="create-actions">
                        <button type="button" onclick="saveManualRecipe()" class="save-recipe-btn">
                            <i class="fas fa-save"></i> Save Recipe
                        </button>
                        <button type="button" onclick="closeCreateModal()" class="cancel-create-btn">
                            <i class="fas fa-times"></i> Cancel
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Recipe Selection Modal -->
    <div id="recipeSelectionModal" class="recipe-selection-modal">
        <div class="recipe-selection-content">
            <div class="recipe-selection-header">
                <h2 class="recipe-selection-title">
                    <i class="fas fa-utensils"></i> Select Recipes for Shopping List
                </h2>
                <button class="close-btn" onclick="closeRecipeSelectionModal()">&times;</button>
            </div>
            <div class="recipe-selection-body">
                <div id="recipeCheckboxList">
                    <!-- Recipe checkboxes will be populated here -->
                </div>
                <div class="generation-actions">
                    <button onclick="generateShoppingList()" class="generate-list-btn">
                        <i class="fas fa-list"></i> Generate Shopping List
                    </button>
                    <button onclick="closeRecipeSelectionModal()" class="cancel-selection-btn">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Shopping List Modal -->
    <div id="shoppingListModal" class="shopping-list-modal">
        <div class="shopping-list-content">
            <div class="shopping-list-header">
                <h2 class="shopping-list-title">
                    <i class="fas fa-shopping-cart"></i> Shopping List
                </h2>
                <div class="shopping-list-actions">
                    <button onclick="openAddMoreRecipes()" class="add-more-btn">
                        <i class="fas fa-plus"></i> Add More
                    </button>
                    <button onclick="clearShoppingList()" class="clear-list-btn">
                        <i class="fas fa-trash"></i> Clear
                    </button>
                    <button class="close-btn" onclick="closeShoppingListModal()">&times;</button>
                </div>
            </div>
            <div class="shopping-list-body">
                <div id="shoppingStats" class="shopping-stats">
                    <!-- Shopping stats will be shown here -->
                </div>
                <div id="shoppingListItems">
                    <!-- Shopping list items will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // CORS proxies for recipe extraction
        const CORS_PROXIES = [
            'https://api.allorigins.win/raw?url=',
            'https://corsproxy.io/?',
            'https://cors-anywhere.herokuapp.com/'
        ];
        const GOOGLE_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbxUULLe9sRmSRG7wvewTPgwKYBXd9yxhqQKKzT_XgeF2IPyJKPQ_HWEJduwu1bW81E8mw/exec';
        
        // Set this to false to use Google Sheets, true to use localStorage for testing
        const USE_LOCAL_STORAGE = true;
        
        // Global variables
        let recipes = [];
        let currentPassword = null;
        let isSessionOnly = false;
        let extractionStats = {
            totalAttempts: 0,
            successfulExtractions: 0,
            strategiesUsed: {},
            errors: [],
            performance: {}
        };
        let ingredientCount = 0;
        let instructionCount = 0;
        let createRecipeBtn, createRecipeModal, createCloseBtn;
        let isEditMode = false;
        let editingRecipeId = null;
        let originalRecipeData = null;
        let shoppingListBtn, recipeSelectionModal, shoppingListModal;
        let selectedRecipes = []; // Array of {recipeId, quantity}
        let shoppingListItems = []; // Array of {ingredient, checked, id}
        let isAddingMoreRecipes = false;

        // DOM elements (will be available after DOM loads)
        let passwordModal, passwordInput, loginBtn, skipPasswordBtn;
        let currentPasswordDisplay, recipeUrlInput, addRecipeBtn;
        let messageContainer, recipeGrid, loadingRecipes, modal, modalTitle, modalBody;

        // Initialize app when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            // Get DOM elements
            passwordModal = document.getElementById('passwordModal');
            passwordInput = document.getElementById('passwordInput');
            loginBtn = document.getElementById('loginBtn');
            skipPasswordBtn = document.getElementById('skipPasswordBtn');
            currentPasswordDisplay = document.getElementById('currentPassword');
            recipeUrlInput = document.getElementById('recipeUrl');
            addRecipeBtn = document.getElementById('addRecipeBtn');
            messageContainer = document.getElementById('messageContainer');
            recipeGrid = document.getElementById('recipeGrid');
            loadingRecipes = document.getElementById('loadingRecipes');
            modal = document.getElementById('recipeModal');
            modalTitle = document.getElementById('modalTitle');
            modalBody = document.getElementById('modalBody');
            createRecipeBtn = document.getElementById('createRecipeBtn');
            createRecipeModal = document.getElementById('createRecipeModal');
            createCloseBtn = document.querySelector('.create-close');
            shoppingListBtn = document.getElementById('shoppingListBtn');
            recipeSelectionModal = document.getElementById('recipeSelectionModal');
            shoppingListModal = document.getElementById('shoppingListModal');

            // Show password modal first
            showPasswordModal();
            
            // Event listeners
            if (loginBtn) loginBtn.addEventListener('click', loginWithPassword);
            if (skipPasswordBtn) skipPasswordBtn.addEventListener('click', skipPassword);
            if (addRecipeBtn) addRecipeBtn.addEventListener('click', addRecipe);
            if (recipeUrlInput) {
                recipeUrlInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') addRecipe();
                });
            }
            if (passwordInput) {
                passwordInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') loginWithPassword();
                });
            }
            if (createRecipeBtn) createRecipeBtn.addEventListener('click', openCreateModal);
            if (createCloseBtn) createCloseBtn.addEventListener('click', closeCreateModal);
            
            // Close modal functionality
            const closeBtn = document.querySelector('.close');
            if (closeBtn) closeBtn.addEventListener('click', closeModal);
            window.addEventListener('click', (e) => {
                if (e.target === modal) closeModal();
            });

            // Close modal when clicking outside (ADD this to existing window click listener or create new one)
            window.addEventListener('click', (e) => {
                if (e.target === createRecipeModal) closeCreateModal();
            });
            if (shoppingListBtn) shoppingListBtn.addEventListener('click', openShoppingListFlow);

            // Load saved shopping list on page load
            loadShoppingList();
        });

        // Password management functions
        function showPasswordModal() {
            if (passwordModal) {
                passwordModal.style.display = 'block';
                if (passwordInput) passwordInput.focus();
            }
        }

        function hidePasswordModal() {
            if (passwordModal) passwordModal.style.display = 'none';
        }

        async function loginWithPassword() {
            const password = passwordInput ? passwordInput.value.trim() : '';
            
            if (!password) {
                showMessage('Please enter a password');
                return;
            }
            
            console.log('🔐 Logging in with password...');
            
            currentPassword = password;
            isSessionOnly = false;
            
            hidePasswordModal();
            updatePasswordDisplay();
            
            // ✅ CRITICAL: Load recipes from Google Sheets and populate local array
            await loadRecipes();
            
            showMessage(`Logged in successfully! Your recipes are saved to the cloud.`, 'success');
            
            console.log('Login complete. Local recipes:', recipes.length);
        }

        function skipPassword() {
            currentPassword = null;
            isSessionOnly = true;
            
            hidePasswordModal();
            updatePasswordDisplay();
            recipes = [];
            renderRecipes();
            
            showMessage('Session mode: Recipes will not be saved when you close the browser.', 'warning');
        }

        function logout() {
            currentPassword = null;
            isSessionOnly = false;
            recipes = [];
            renderRecipes();
            updatePasswordDisplay();
            showPasswordModal();
        }

        function updatePasswordDisplay() {
            if (!currentPasswordDisplay) return;
            
            if (currentPassword) {
                currentPasswordDisplay.innerHTML = `
                    <span>Password: <strong>${maskPassword(currentPassword)}</strong> (Cloud Save)</span>
                    <button onclick="logout()" class="logout-btn">Logout</button>
                `;
                currentPasswordDisplay.style.display = 'flex';
            } else if (isSessionOnly) {
                currentPasswordDisplay.innerHTML = `
                    <span>Session Mode (Not Saved)</span>
                    <button onclick="logout()" class="logout-btn">Login</button>
                `;
                currentPasswordDisplay.style.display = 'flex';
            } else {
                currentPasswordDisplay.style.display = 'none';
            }
        }

        function maskPassword(password) {
            if (password.length <= 3) return '*'.repeat(password.length);
            return password.substring(0, 2) + '*'.repeat(password.length - 2);
        }

        // Recipe management functions
        async function addRecipe() {
            const url = recipeUrlInput ? recipeUrlInput.value.trim() : '';
            
            if (!url) {
                showMessage('Please enter a recipe URL');
                return;
            }
            
            if (!isValidUrl(url)) {
                showMessage('Please enter a valid URL');
                return;
            }
            
            setLoading(true);
            debugLog('=== STARTING NEW RECIPE EXTRACTION ===', 'info');
            
            try {
                // Check if recipe already exists
                const existingRecipe = recipes.find(recipe => recipe.url === url);
                if (existingRecipe) {
                    const shouldOverwrite = confirm('This recipe already exists. Do you want to overwrite it?');
                    if (!shouldOverwrite) {
                        setLoading(false);
                        return;
                    }
                }
                
                // Extract recipe data
                const recipeData = await extractRecipeData(url);
                
                // Add timestamp and ID
                recipeData.dateAdded = new Date().toISOString();
                recipeData.id = Date.now().toString();
                
                debugLog('Recipe extraction completed successfully', 'success', {
                    title: recipeData.title,
                    ingredients: recipeData.ingredients.length,
                    instructions: recipeData.instructions.length
                });
                
                // Save recipe
                if (isSessionOnly) {
                    // Session-only mode: just add to local array
                    if (existingRecipe) {
                        const index = recipes.findIndex(recipe => recipe.url === url);
                        recipes[index] = recipeData;
                    } else {
                        recipes.push(recipeData);
                    }
                    showMessage('Recipe added to session (not saved permanently)', 'success');
                } else {
                    // Cloud mode: save to Google Sheets
                    await saveRecipeToSheet(recipeData);
                    
                    // Update local recipes array
                    if (existingRecipe) {
                        const index = recipes.findIndex(recipe => recipe.url === url);
                        recipes[index] = recipeData;
                    } else {
                        recipes.push(recipeData);
                    }
                    showMessage('Recipe saved to cloud successfully!', 'success');
                }
                
                // Clear input and refresh display
                if (recipeUrlInput) recipeUrlInput.value = '';
                renderRecipes();
                
            } catch (error) {
                debugLog(`Recipe extraction failed: ${error.message}`, 'error');
                showMessage(error.message);
            } finally {
                setLoading(false);
                debugLog('=== RECIPE EXTRACTION COMPLETED ===', 'info');
            }
        }

        // CORS-friendly Google Sheets functions
        async function saveRecipeToSheet(recipeData) {
            if (!currentPassword) {
                throw new Error('No password set - cannot save to cloud');
            }

            const response = await fetch(GOOGLE_SCRIPT_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'text/plain;charset=utf-8', // KEY: Use text/plain to avoid CORS preflight
                },
                body: JSON.stringify({
                    action: 'add',
                    password: currentPassword,
                    recipe: recipeData
                }),
                redirect: 'follow'
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const resultText = await response.text();
            const result = JSON.parse(resultText);
            
            if (!result.success) {
                throw new Error(result.message || 'Failed to save recipe to Google Sheets');
            }
        }

        async function loadRecipesFromSheet() {
            if (!currentPassword) {
                console.log('No password provided - returning empty array');
                return [];
            }

            console.log('📡 Fetching from Google Sheets...');
            
            const response = await fetch(`${GOOGLE_SCRIPT_URL}?action=get&password=${encodeURIComponent(currentPassword)}`, {
                method: 'GET',
                redirect: 'follow'
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const resultText = await response.text();
            console.log('Raw response length:', resultText.length);
            
            let result;
            try {
                result = JSON.parse(resultText);
            } catch (parseError) {
                console.error('Failed to parse response:', resultText.substring(0, 200) + '...');
                throw new Error('Invalid response from server');
            }
            
            console.log('Parsed response:', result);
            
            if (!result.success) {
                throw new Error(result.message || 'Failed to load recipes from Google Sheets');
            }
            
            const rawRecipes = result.data || [];
            console.log(`📥 Raw recipes from sheets: ${rawRecipes.length}`);
            
            // ✅ CRITICAL: Parse and normalize the recipe data
            const processedRecipes = rawRecipes.map((recipe, index) => {
                try {
                    // Ensure ID is always a string for consistency
                    const processedRecipe = {
                        ...recipe,
                        id: String(recipe.id), // Convert to string
                        // Parse ingredients and instructions if they're JSON strings
                        ingredients: typeof recipe.ingredients === 'string' ? 
                            JSON.parse(recipe.ingredients) : 
                            (Array.isArray(recipe.ingredients) ? recipe.ingredients : []),
                        instructions: typeof recipe.instructions === 'string' ? 
                            JSON.parse(recipe.instructions) : 
                            (Array.isArray(recipe.instructions) ? recipe.instructions : [])
                    };
                    
                    console.log(`Processed recipe ${index + 1}:`, {
                        id: processedRecipe.id,
                        idType: typeof processedRecipe.id,
                        ingredientsCount: processedRecipe.ingredients.length,
                        instructionsCount: processedRecipe.instructions.length,
                        title: processedRecipe.title
                    });
                    
                    return processedRecipe;
                    
                } catch (parseError) {
                    console.error(`Error processing recipe ${index + 1}:`, parseError);
                    console.error('Raw recipe data:', recipe);
                    
                    // Return a safe fallback
                    return {
                        ...recipe,
                        id: String(recipe.id),
                        ingredients: ['Error parsing ingredients'],
                        instructions: ['Error parsing instructions']
                    };
                }
            });
            
            console.log(`✅ Successfully processed ${processedRecipes.length} recipes from Google Sheets`);
            
            return processedRecipes;
        }

        async function deleteRecipeFromSheet(recipeId) {
            if (isSessionOnly) {
                console.log('Session-only mode - no sheet deletion needed');
                return;
            }

            if (!currentPassword) {
                throw new Error('No password set - cannot delete from cloud');
            }

            console.log('🔍 Deleting from sheet with:', {
                recipeId: recipeId,
                recipeIdType: typeof recipeId,
                password: currentPassword ? '***' + currentPassword.slice(-2) : 'none',
                passwordType: typeof currentPassword
            });

            const response = await fetch(GOOGLE_SCRIPT_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'text/plain;charset=utf-8',
                },
                body: JSON.stringify({
                    action: 'delete',
                    password: currentPassword,
                    recipeId: recipeId.toString() // Ensure it's a string for comparison
                }),
                redirect: 'follow'
            });

            if (!response.ok) {
                console.error('HTTP error:', response.status, response.statusText);
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const resultText = await response.text();
            console.log('Raw response from Google Sheets:', resultText);
            
            let result;
            try {
                result = JSON.parse(resultText);
            } catch (parseError) {
                console.error('Failed to parse response as JSON:', parseError);
                throw new Error('Invalid response from server: ' + resultText);
            }
            
            console.log('Parsed response:', result);
            
            if (!result.success) {
                throw new Error(result.message || 'Failed to delete recipe from Google Sheets');
            }
        }

        async function loadRecipes() {
            if (isSessionOnly) {
                console.log('Session-only mode: using existing recipes in memory');
                console.log('Current recipes in session:', recipes.length);
                renderRecipes();
                return;
            }
            
            if (loadingRecipes) loadingRecipes.style.display = 'flex';
            
            try {
                console.log('🔄 Loading recipes from Google Sheets...');
                console.log('Current password:', currentPassword ? '***' + currentPassword.slice(-2) : 'none');
                
                // Fetch recipes from Google Sheets
                const fetchedRecipes = await loadRecipesFromSheet();
                
                console.log('📥 Fetched recipes from sheets:', fetchedRecipes.length);
                console.log('Sample fetched recipe IDs:', fetchedRecipes.slice(0, 3).map(r => `"${r.id}" (${typeof r.id})`));
                
                // ✅ CRITICAL: Update the local recipes array
                recipes = fetchedRecipes;
                
                console.log('✅ Local recipes array updated:', recipes.length);
                console.log('Sample local recipe IDs:', recipes.slice(0, 3).map(r => `"${r.id}" (${typeof r.id})`));
                
                // Update the UI
                renderRecipes();
                
                console.log('✅ Recipes loaded and UI updated successfully');
                
            } catch (error) {
                console.error('❌ Failed to load recipes:', error);
                showMessage('Failed to load recipes: ' + error.message);
                
                // Keep existing recipes in case of error
                renderRecipes();
            } finally {
                if (loadingRecipes) loadingRecipes.style.display = 'none';
            }
        }

        async function deleteRecipe(recipeId) {
            if (!confirm('Are you sure you want to delete this recipe?')) return;
            
            console.log('🗑️ Starting delete process for recipe ID:', recipeId, typeof recipeId);
            
            // Convert recipeId to string for consistent comparison
            const targetId = String(recipeId);
            console.log('Target ID (as string):', targetId);
            
            // Find the recipe to delete (compare as strings)
            const recipeToDelete = recipes.find(r => String(r.id) === targetId);
            console.log('Recipe found in local array:', !!recipeToDelete);
            
            if (!recipeToDelete) {
                console.error('❌ Recipe not found in local list');
                console.log('Available recipe IDs:', recipes.map(r => `"${String(r.id)}"`));
                showMessage('Recipe not found in local list', 'error');
                return;
            }
            
            console.log('Found recipe to delete:', recipeToDelete.title);
            
            // Backup recipes in case we need to restore
            const originalRecipes = [...recipes];
            
            // Optimistically remove from UI
            recipes = recipes.filter(recipe => String(recipe.id) !== targetId);
            renderRecipes();
            
            // Show loading message
            const tempMessage = isSessionOnly ? 
                'Removing recipe from session...' : 
                'Deleting recipe from cloud...';
            showMessage(tempMessage, 'info');
            
            try {
                // Delete from Google Sheets if not session-only
                if (!isSessionOnly) {
                    console.log('Attempting to delete from Google Sheets...');
                    await deleteRecipeFromSheet(targetId); // Pass as string
                    console.log('✅ Successfully deleted from Google Sheets');
                } else {
                    console.log('Session-only mode - skipping Google Sheets deletion');
                }
                
                // Success!
                const successMessage = isSessionOnly ? 
                    'Recipe removed from session' : 
                    'Recipe deleted from cloud successfully!';
                showMessage(successMessage, 'success');
                
                console.log(`✅ Recipe "${recipeToDelete.title}" deleted successfully`);
                
            } catch (error) {
                console.error('❌ Delete failed:', error);
                
                // Restore recipes since deletion failed
                recipes = originalRecipes;
                renderRecipes();
                
                showMessage('Failed to delete recipe: ' + error.message, 'error');
            }
        }

        // Also update your renderRecipes function to handle empty state better
        function renderRecipes() {
            if (!recipeGrid) return;
            
            const statusText = isSessionOnly ? ' (Session Only - Not Saved)' : 
                            currentPassword ? ` (${recipes.length} saved to cloud)` : '';
            
            if (recipes.length === 0) {
                recipeGrid.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-utensils"></i>
                        <h3>No recipes yet${statusText}</h3>
                        <p>Add your first recipe by pasting a URL above</p>
                    </div>
                `;
                return;
            }
            
            const recipeCards = recipes.map((recipe, index) => {
                // Ensure ID is a string for HTML attributes
                const recipeId = String(recipe.id);
                
                return `
                <div class="recipe-card" onclick="openRecipeModal('${recipeId}')" style="animation-delay: ${index * 50}ms;">
                    <img src="${recipe.image || 'https://via.placeholder.com/80x80?text=No+Image'}" 
                        alt="${recipe.title}" 
                        onerror="this.src='https://via.placeholder.com/80x80?text=No+Image'">
                    
                    <div class="recipe-card-content">
                        <div class="recipe-info">
                            <h3 class="recipe-title">${recipe.title}</h3>
                            <div class="recipe-meta">
                                <span><i class="fas fa-clock"></i> ${recipe.totalTime || 'N/A'}</span>
                                <span><i class="fas fa-users"></i> ${recipe.servings || 'N/A'}</span>
                                <span><i class="fas fa-list"></i> ${recipe.ingredients?.length || 0} ingredients</span>
                            </div>
                            <p class="recipe-description">${recipe.description || 'No description available'}</p>
                        </div>
                        
                        <div class="recipe-actions">
                            <button class="view-btn" onclick="event.stopPropagation(); openRecipeModal('${recipeId}')" title="View Recipe">
                                <i class="fas fa-eye"></i>
                            </button>
                            <button class="delete-btn" onclick="event.stopPropagation(); deleteRecipe('${recipeId}')" title="Delete Recipe">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                </div>
                `;
            }).join('');
            
            recipeGrid.innerHTML = recipeCards;
            
            // Update header with status info
            const headerElement = document.querySelector('.recipe-header p');
            if (headerElement) {
                const baseText = 'Add, organize, and manage your favorite dinner recipes. Simply paste a recipe URL to automatically extract ingredients and cooking instructions.';
                headerElement.textContent = baseText + statusText;
            }
        }

        // Add saving indicator to the DOM (add this after DOMContentLoaded)
        function addSavingIndicator() {
            const indicator = document.createElement('div');
            indicator.id = 'savingIndicator';
            indicator.className = 'saving-indicator';
            indicator.innerHTML = ' Saving changes...';
            document.body.appendChild(indicator);
        }

        // Add saving indicator to the DOM
        function addSavingIndicator() {
            const indicator = document.createElement('div');
            indicator.id = 'savingIndicator';
            indicator.className = 'saving-indicator';
            indicator.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving changes...';
            document.body.appendChild(indicator);
        }

        // Render recipe content (view or edit mode)
        function renderRecipeContent(recipe, editMode = false) {
            isEditMode = editMode;
            
            if (editMode) {
                modalBody.innerHTML = `
                    <div class="edit-mode-header">
                        <h3 class="edit-mode-title">
                            <i class="fas fa-edit"></i> Editing Recipe
                        </h3>
                        <div class="edit-actions">
                            <button onclick="saveRecipeChanges()" class="save-btn">
                                <i class="fas fa-save"></i> Save Changes
                            </button>
                            <button onclick="cancelEdit()" class="cancel-btn">
                                <i class="fas fa-times"></i> Cancel
                            </button>
                        </div>
                    </div>
                    
                    <div class="recipe-info">
                        <div class="ingredients-section">
                            <div class="section-header">
                                <h3 class="section-title">
                                    <i class="fas fa-list"></i> Ingredients
                                </h3>
                            </div>
                            <ul class="editable-list" id="editableIngredients">
                                ${renderEditableIngredients(recipe.ingredients)}
                            </ul>
                            <div class="add-item-section">
                                <button onclick="addNewIngredient()" class="add-item-btn">
                                    <i class="fas fa-plus"></i> Add Ingredient
                                </button>
                            </div>
                        </div>
                        
                        <div class="instructions-section">
                            <div class="section-header">
                                <h3 class="section-title">
                                    <i class="fas fa-clipboard-list"></i> Instructions
                                </h3>
                            </div>
                            <ol class="editable-list" id="editableInstructions">
                                ${renderEditableInstructions(recipe.instructions)}
                            </ol>
                            <div class="add-item-section">
                                <button onclick="addNewInstruction()" class="add-item-btn">
                                    <i class="fas fa-plus"></i> Add Instruction
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    ${recipe.image ? `<img src="${recipe.image}" style="width: 100%; max-width: 400px; border-radius: 10px; margin: 20px auto; display: block;" alt="${recipe.title}">` : ''}
                    <div style="text-align: center; margin-top: 20px;">
                        <a href="${recipe.url}" target="_blank" class="btn" style="display: inline-block;">
                            <i class="fas fa-external-link-alt"></i> View Original Recipe
                        </a>
                    </div>
                `;
            } else {
                modalBody.innerHTML = `
                    <div style="text-align: right; margin-bottom: 20px;">
                        <button onclick="enterEditMode()" class="edit-btn">
                            <i class="fas fa-edit"></i> Edit Recipe
                        </button>
                    </div>
                    
                    <div class="recipe-info">
                        <div class="ingredients-section">
                            <h3 class="section-title">
                                <i class="fas fa-list"></i> Ingredients
                            </h3>
                            <ul class="ingredients-list">
                                ${(recipe.ingredients || []).map(ingredient => `<li>${ingredient}</li>`).join('')}
                            </ul>
                        </div>
                        <div class="instructions-section">
                            <h3 class="section-title">
                                <i class="fas fa-clipboard-list"></i> Instructions
                            </h3>
                            <ol class="instructions-list">
                                ${(recipe.instructions || []).map(instruction => `<li>${instruction}</li>`).join('')}
                            </ol>
                        </div>
                    </div>
                    ${recipe.image ? `<img src="${recipe.image}" style="width: 100%; max-width: 400px; border-radius: 10px; margin: 20px auto; display: block;" alt="${recipe.title}">` : ''}
                    <div style="text-align: center; margin-top: 20px;">
                        <a href="${recipe.url}" target="_blank" class="btn" style="display: inline-block;">
                            <i class="fas fa-external-link-alt"></i> View Original Recipe
                        </a>
                    </div>
                `;
            }
        }

        // Render editable ingredients
        function renderEditableIngredients(ingredients) {
            return ingredients.map((ingredient, index) => `
                <li class="editable-item" data-index="${index}">
                    <input type="text" class="editable-input" value="${escapeHtml(ingredient)}" 
                        onchange="updateIngredient(${index}, this.value)">
                    <div class="item-controls">
                        <button onclick="moveIngredient(${index}, -1)" class="move-btn" title="Move Up" ${index === 0 ? 'disabled' : ''}>
                            <i class="fas fa-arrow-up"></i>
                        </button>
                        <button onclick="moveIngredient(${index}, 1)" class="move-btn" title="Move Down" ${index === ingredients.length - 1 ? 'disabled' : ''}>
                            <i class="fas fa-arrow-down"></i>
                        </button>
                        <button onclick="removeIngredient(${index})" class="remove-btn" title="Remove">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </li>
            `).join('');
        }

        // Render editable instructions
        function renderEditableInstructions(instructions) {
            return instructions.map((instruction, index) => `
                <li class="editable-item" data-index="${index}">
                    <textarea class="editable-textarea" onchange="updateInstruction(${index}, this.value)">${escapeHtml(instruction)}</textarea>
                    <div class="item-controls">
                        <button onclick="moveInstruction(${index}, -1)" class="move-btn" title="Move Up" ${index === 0 ? 'disabled' : ''}>
                            <i class="fas fa-arrow-up"></i>
                        </button>
                        <button onclick="moveInstruction(${index}, 1)" class="move-btn" title="Move Down" ${index === instructions.length - 1 ? 'disabled' : ''}>
                            <i class="fas fa-arrow-down"></i>
                        </button>
                        <button onclick="removeInstruction(${index})" class="remove-btn" title="Remove">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </li>
            `).join('');
        }

        // Edit mode functions
        function enterEditMode() {
            const recipe = recipes.find(r => String(r.id) === editingRecipeId);
            if (recipe) {
                renderRecipeContent(recipe, true);
            }
        }

        function cancelEdit() {
            const recipe = recipes.find(r => String(r.id) === editingRecipeId);
            if (recipe) {
                renderRecipeContent(recipe, false);
            }
        }

        // Ingredient management functions
        function updateIngredient(index, value) {
            const recipe = recipes.find(r => String(r.id) === editingRecipeId);
            if (recipe && recipe.ingredients[index] !== undefined) {
                recipe.ingredients[index] = value.trim();
            }
        }

        function addNewIngredient() {
            const recipe = recipes.find(r => String(r.id) === editingRecipeId);
            if (recipe) {
                recipe.ingredients.push('New ingredient');
                renderRecipeContent(recipe, true);
            }
        }

        function removeIngredient(index) {
            const recipe = recipes.find(r => String(r.id) === editingRecipeId);
            if (recipe && recipe.ingredients.length > 1) { // Keep at least one ingredient
                recipe.ingredients.splice(index, 1);
                renderRecipeContent(recipe, true);
            }
        }

        function moveIngredient(index, direction) {
            const recipe = recipes.find(r => String(r.id) === editingRecipeId);
            if (!recipe) return;
            
            const newIndex = index + direction;
            if (newIndex >= 0 && newIndex < recipe.ingredients.length) {
                // Swap ingredients
                [recipe.ingredients[index], recipe.ingredients[newIndex]] = 
                [recipe.ingredients[newIndex], recipe.ingredients[index]];
                renderRecipeContent(recipe, true);
            }
        }

        // Instruction management functions
        function updateInstruction(index, value) {
            const recipe = recipes.find(r => String(r.id) === editingRecipeId);
            if (recipe && recipe.instructions[index] !== undefined) {
                recipe.instructions[index] = value.trim();
            }
        }

        function addNewInstruction() {
            const recipe = recipes.find(r => String(r.id) === editingRecipeId);
            if (recipe) {
                recipe.instructions.push('New instruction step');
                renderRecipeContent(recipe, true);
            }
        }

        function removeInstruction(index) {
            const recipe = recipes.find(r => String(r.id) === editingRecipeId);
            if (recipe && recipe.instructions.length > 1) { // Keep at least one instruction
                recipe.instructions.splice(index, 1);
                renderRecipeContent(recipe, true);
            }
        }

        function moveInstruction(index, direction) {
            const recipe = recipes.find(r => String(r.id) === editingRecipeId);
            if (!recipe) return;
            
            const newIndex = index + direction;
            if (newIndex >= 0 && newIndex < recipe.instructions.length) {
                // Swap instructions
                [recipe.instructions[index], recipe.instructions[newIndex]] = 
                [recipe.instructions[newIndex], recipe.instructions[index]];
                renderRecipeContent(recipe, true);
            }
        }

        // Save changes function
        async function saveRecipeChanges() {
            const recipe = recipes.find(r => String(r.id) === editingRecipeId);
            if (!recipe) {
                showMessage('Recipe not found', 'error');
                return;
            }
            
            try {
                showSavingIndicator();
                
                // Clean up the recipe data
                recipe.ingredients = recipe.ingredients.filter(ing => ing.trim().length > 0);
                recipe.instructions = recipe.instructions.filter(inst => inst.trim().length > 0);
                
                if (recipe.ingredients.length === 0) {
                    recipe.ingredients = ['No ingredients specified'];
                }
                if (recipe.instructions.length === 0) {
                    recipe.instructions = ['No instructions specified'];
                }
                
                // Update timestamp
                recipe.lastModified = new Date().toISOString();
                
                // Save to Google Sheets if not in session-only mode
                if (!isSessionOnly && currentPassword) {
                    await updateRecipeInSheet(recipe);
                }
                
                // Update local array and re-render
                const recipeIndex = recipes.findIndex(r => String(r.id) === editingRecipeId);
                if (recipeIndex !== -1) {
                    recipes[recipeIndex] = recipe;
                }
                
                // Exit edit mode and show updated recipe
                renderRecipeContent(recipe, false);
                renderRecipes(); // Update the main recipe list
                
                hideSavingIndicator();
                showMessage(isSessionOnly ? 'Recipe updated in session' : 'Recipe updated successfully!', 'success');
                
            } catch (error) {
                hideSavingIndicator();
                console.error('Failed to save recipe changes:', error);
                showMessage('Failed to save changes: ' + error.message, 'error');
                
                // Restore original data on error
                const recipeIndex = recipes.findIndex(r => String(r.id) === editingRecipeId);
                if (recipeIndex !== -1 && originalRecipeData) {
                    recipes[recipeIndex] = originalRecipeData;
                    renderRecipeContent(originalRecipeData, true);
                }
            }
        }

        // Update recipe in Google Sheets
        async function updateRecipeInSheet(recipeData) {
            if (!currentPassword) {
                throw new Error('No password set - cannot save to cloud');
            }

            const response = await fetch(GOOGLE_SCRIPT_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'text/plain;charset=utf-8',
                },
                body: JSON.stringify({
                    action: 'update',
                    password: currentPassword,
                    recipeId: recipeData.id,
                    recipe: recipeData
                }),
                redirect: 'follow'
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const resultText = await response.text();
            const result = JSON.parse(resultText);
            
            if (!result.success) {
                throw new Error(result.message || 'Failed to update recipe in Google Sheets');
            }
        }

        // Utility functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showSavingIndicator() {
            const indicator = document.getElementById('savingIndicator');
            if (indicator) {
                indicator.classList.add('show');
            }
        }

        function hideSavingIndicator() {
            const indicator = document.getElementById('savingIndicator');
            if (indicator) {
                indicator.classList.remove('show');
            }
        }

        // Open recipe modal
        function openRecipeModal(recipeId) {
            const targetId = String(recipeId);
            const recipe = recipes.find(r => String(r.id) === targetId);
            
            if (!recipe || !modal || !modalTitle || !modalBody) {
                console.error('Could not open modal - recipe or modal elements not found');
                return;
            }
            
            editingRecipeId = targetId;
            originalRecipeData = JSON.parse(JSON.stringify(recipe)); // Deep clone
            
            modalTitle.textContent = recipe.title;
            renderRecipeContent(recipe, false); // false = view mode
            
            modal.style.display = 'block';
        }

        // Close modal
        function closeModal() {
            if (modal) modal.style.display = 'none';
        }

        // Utility functions
        function showMessage(message, type = 'error') {
            if (!messageContainer) return;
            messageContainer.innerHTML = `<div class="${type}-message">${message}</div>`;
            setTimeout(() => {
                messageContainer.innerHTML = '';
            }, 5000);
        }

        function setLoading(isLoading) {
            if (!addRecipeBtn) return;
            addRecipeBtn.disabled = isLoading;
            addRecipeBtn.innerHTML = isLoading ? 
                '<div class="spinner"></div> Processing...' : 
                '<i class="fas fa-plus"></i> Add Recipe';
        }

        function isValidUrl(string) {
            try {
                new URL(string);
                return true;
            } catch (_) {
                return false;
            }
        }

        // Debug functions (console only)
        function debugLog(message, type = 'info', data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = `[${timestamp}] ${type.toUpperCase()}:`;
            
            switch(type) {
                case 'error':
                    console.error(prefix, message, data || '');
                    break;
                case 'warning':
                    console.warn(prefix, message, data || '');
                    break;
                case 'success':
                    console.log(`%c${prefix} ${message}`, 'color: green; font-weight: bold;', data || '');
                    break;
                case 'info':
                default:
                    console.log(prefix, message, data || '');
                    break;
            }
        }

        function debugStep(stepName, success = true, data = null) {
            const icon = success ? '✅' : '❌';
            const timestamp = new Date().toLocaleTimeString();
            const style = success ? 'color: green;' : 'color: red;';
            
            console.log(`%c[${timestamp}] ${icon} ${stepName}`, style, data || '');
        }

        function updateExtractionStats(strategy, success, timeTaken, errors = []) {
            extractionStats.totalAttempts++;
            if (success) extractionStats.successfulExtractions++;
            
            if (!extractionStats.strategiesUsed[strategy]) {
                extractionStats.strategiesUsed[strategy] = { attempts: 0, successes: 0 };
            }
            extractionStats.strategiesUsed[strategy].attempts++;
            if (success) extractionStats.strategiesUsed[strategy].successes++;
            
            extractionStats.performance[strategy] = timeTaken;
            if (errors.length > 0) {
                extractionStats.errors = extractionStats.errors.concat(errors);
            }
            
            console.group('📊 Extraction Statistics');
            console.log('Total Attempts:', extractionStats.totalAttempts);
            console.log('Successful:', extractionStats.successfulExtractions);
            console.log('Success Rate:', Math.round((extractionStats.successfulExtractions / extractionStats.totalAttempts) * 100) + '%');
            console.log('Strategies Used:', extractionStats.strategiesUsed);
            console.log('Performance:', extractionStats.performance);
            if (errors.length > 0) console.log('Errors:', errors);
            console.groupEnd();
        }

        // Navigation functions
        function openmenu() {
            const sidemenu = document.getElementById("sidemenu");
            if (sidemenu) sidemenu.style.right = "0";
        }

        function closemenu() {
            const sidemenu = document.getElementById("sidemenu");
            if (sidemenu) sidemenu.style.right = "-200px";
        }

        // Simplified debug logging functions - Console only
        function debugLog(message, type = 'info', data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = `[${timestamp}] ${type.toUpperCase()}:`;
            
            // Use different console methods based on type
            switch(type) {
                case 'error':
                    console.error(prefix, message, data || '');
                    break;
                case 'warning':
                    console.warn(prefix, message, data || '');
                    break;
                case 'success':
                    console.log(`%c${prefix} ${message}`, 'color: green; font-weight: bold;', data || '');
                    break;
                case 'info':
                default:
                    console.log(prefix, message, data || '');
                    break;
            }
        }

        function debugStep(stepName, success = true, data = null) {
            const icon = success ? '✅' : '❌';
            const timestamp = new Date().toLocaleTimeString();
            const style = success ? 'color: green;' : 'color: red;';
            
            console.log(`%c[${timestamp}] ${icon} ${stepName}`, style, data || '');
        }

        function updateExtractionStats(strategy, success, timeTaken, errors = []) {
            extractionStats.totalAttempts++;
            if (success) extractionStats.successfulExtractions++;
            
            if (!extractionStats.strategiesUsed[strategy]) {
                extractionStats.strategiesUsed[strategy] = { attempts: 0, successes: 0 };
            }
            extractionStats.strategiesUsed[strategy].attempts++;
            if (success) extractionStats.strategiesUsed[strategy].successes++;
            
            extractionStats.performance[strategy] = timeTaken;
            if (errors.length > 0) {
                extractionStats.errors = extractionStats.errors.concat(errors);
            }
            
            // Log stats to console instead of UI
            console.group('📊 Extraction Statistics');
            console.log('Total Attempts:', extractionStats.totalAttempts);
            console.log('Successful:', extractionStats.successfulExtractions);
            console.log('Success Rate:', Math.round((extractionStats.successfulExtractions / extractionStats.totalAttempts) * 100) + '%');
            console.log('Strategies Used:', extractionStats.strategiesUsed);
            console.log('Performance:', extractionStats.performance);
            if (errors.length > 0) console.log('Errors:', errors);
            console.groupEnd();
        }

        function displayExtractionStats() {
            const statsDiv = document.createElement('div');
            statsDiv.className = 'extraction-stats';
            statsDiv.innerHTML = `
                <div class="stat-item">
                    <div class="stat-value">${extractionStats.totalAttempts}</div>
                    <div class="stat-label">Total Attempts</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${extractionStats.successfulExtractions}</div>
                    <div class="stat-label">Successful</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${Math.round((extractionStats.successfulExtractions / extractionStats.totalAttempts) * 100) || 0}%</div>
                    <div class="stat-label">Success Rate</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${Object.keys(extractionStats.strategiesUsed).length}</div>
                    <div class="stat-label">Strategies Tried</div>
                </div>
            `;
            
            // Remove existing stats and add new ones
            const existingStats = debugLogsContainer.querySelector('.extraction-stats');
            if (existingStats) existingStats.remove();
            debugLogsContainer.insertBefore(statsDiv, debugLogsContainer.firstChild);
        }

        // Domain-specific extraction rules inspired by recipe-scrapers
        const DOMAIN_RULES = {
            'therealfooddietitians.com': {
                title: ['h1', '.recipe-title', '.entry-title'],
                ingredients: ['[class*="ingredient"]', '.recipe-ingredients li', '.ingredients li', '.recipe-card-ingredients li'],
                instructions: ['[class*="instruction"]', '.recipe-instructions li', '.instructions li', '.recipe-card-instructions li'],
                time: ['.recipe-time', '.total-time', '.prep-time'],
                servings: ['.recipe-yield', '.serves', '.servings']
            },
            'thereciperebel.com': {
                title: ['h1.entry-title', 'h1', '.recipe-title'],
                ingredients: ['.recipe-card-ingredients li', '.wp-block-recipe-card-ingredients li', '.ingredients li', 'li[class*="ingredient"]'],
                instructions: ['.recipe-card-instructions li', '.wp-block-recipe-card-instructions li', '.instructions li', 'li[class*="instruction"]'],
                time: ['.recipe-time', '.total-time'],
                servings: ['.recipe-yield', '.serves']
            },
            'saltandlavender.com': {
                title: ['h1', '.recipe-title'],
                ingredients: ['.recipe-ingredients li', '.ingredients li'],
                instructions: ['.recipe-instructions li', '.instructions li'],
                time: ['.recipe-time', '.total-time'],
                servings: ['.recipe-yield', '.serves']
            },
            'allrecipes.com': {
                title: ['h1', '.recipe-summary__h1'],
                ingredients: ['.recipe-ingred_txt', '.ingredients__item'],
                instructions: ['.recipe-directions__list--item', '.instructions li'],
                time: ['.recipe-adjust-servings__size', '.ready-in-time'],
                servings: ['.recipe-adjust-servings__size', '.recipe-servings']
            },
            'foodnetwork.com': {
                title: ['h1.o-AssetTitle__a-HeadlineText', '.recipe-title'],
                ingredients: ['.o-RecipeIngredient__a-Ingredient', '.ingredients li'],
                instructions: ['.o-Method__m-Step', '.instructions li'],
                time: ['.o-RecipeInfo__a-Description', '.recipe-time'],
                servings: ['.o-RecipeInfo__a-Description', '.recipe-servings']
            },
            'simply-delicious-food.com': {
                title: ['h1', '.recipe-title', '.entry-title'],
                ingredients: ['.recipe-ingredient', 'li[class*="ingredient"]', '.ingredients li'],
                instructions: ['.recipe-instruction', 'li[class*="instruction"]', '.instructions li'],
                time: ['.recipe-prep-time', '.recipe-total-time', '.recipe-time'],
                servings: ['.recipe-servings', '.recipe-yield', '.serves']
            }
        };

        // Comprehensive recipe extraction with multiple strategies
        async function extractRecipeData(url) {
            const startTime = performance.now();
            let html;
            let doc;
            let errors = [];
            let strategy = '';
            
            try {
                debugLog(`Starting recipe extraction for: ${url}`, 'info');
                
                // Try multiple CORS proxies
                debugStep('Fetching HTML content', true);
                html = await fetchWithFallback(url);
                debugLog(`Successfully fetched HTML (${html.length} characters)`, 'success');
                
                // Create a DOM parser to parse the HTML
                const parser = new DOMParser();
                doc = parser.parseFromString(html, 'text/html');
                debugLog('HTML parsed successfully', 'success');
                
                // Get domain for domain-specific rules
                const domain = new URL(url).hostname.replace('www.', '');
                debugLog(`Detected domain: ${domain}`, 'info');
                
                // Strategy 1: JSON-LD structured data (most reliable)
                debugStep('Trying Strategy 1: JSON-LD structured data');
                try {
                    const jsonLdResult = extractFromJsonLD(doc);
                    if (jsonLdResult && jsonLdResult.ingredients.length > 0) {
                        strategy = 'JSON-LD';
                        debugStep('Strategy 1: JSON-LD', true, {
                            ingredients: jsonLdResult.ingredients.length,
                            instructions: jsonLdResult.instructions.length
                        });
                        const result = { ...jsonLdResult, url };
                        updateExtractionStats(strategy, true, performance.now() - startTime);
                        return result;
                    } else {
                        debugStep('Strategy 1: JSON-LD', false, 'No valid JSON-LD data found');
                    }
                } catch (error) {
                    errors.push(`JSON-LD: ${error.message}`);
                    debugStep('Strategy 1: JSON-LD', false, error.message);
                }
                
                // Strategy 2: Domain-specific CSS selectors
                debugStep('Trying Strategy 2: Domain-specific CSS selectors');
                try {
                    const domainResult = extractFromDomainRules(doc, domain, html); // Pass html parameter
                    if (domainResult && domainResult.ingredients.length > 0) {
                        strategy = 'Domain-specific';
                        debugStep('Strategy 2: Domain-specific', true, {
                            ingredients: domainResult.ingredients.length,
                            instructions: domainResult.instructions.length
                        });
                        const result = { ...domainResult, url };
                        updateExtractionStats(strategy, true, performance.now() - startTime, errors);
                        return result;
                    } else {
                        debugStep('Strategy 2: Domain-specific', false, `No rules found for domain: ${domain}`);
                    }
                } catch (error) {
                    errors.push(`Domain-specific: ${error.message}`);
                    debugStep('Strategy 2: Domain-specific', false, error.message);
                }
                
                // Strategy 3: Enhanced text parsing
                debugStep('Trying Strategy 3: Enhanced text parsing');
                try {
                    const textResult = extractFromEnhancedText(html, doc);
                    if (textResult && (textResult.ingredients.length > 1 || textResult.instructions.length > 1)) {
                        strategy = 'Text parsing';
                        debugStep('Strategy 3: Text parsing', true, {
                            ingredients: textResult.ingredients.length,
                            instructions: textResult.instructions.length
                        });
                        const result = { ...textResult, url };
                        updateExtractionStats(strategy, true, performance.now() - startTime, errors);
                        return result;
                    } else {
                        debugStep('Strategy 3: Text parsing', false, `Found ${textResult?.ingredients?.length || 0} ingredients, ${textResult?.instructions?.length || 0} instructions`);
                    }
                } catch (error) {
                    errors.push(`Text parsing: ${error.message}`);
                    debugStep('Strategy 3: Text parsing', false, error.message);
                }
                
                // Strategy 4: Generic CSS selectors
                debugStep('Trying Strategy 4: Generic CSS selectors');
                try {
                    const genericResult = extractFromGenericSelectors(doc, html); // Pass html parameter
                    if (genericResult && (genericResult.ingredients.length > 1 || genericResult.instructions.length > 1)) {
                        strategy = 'Generic CSS';
                        debugStep('Strategy 4: Generic CSS', true, {
                            ingredients: genericResult.ingredients.length,
                            instructions: genericResult.instructions.length
                        });
                        const result = { ...genericResult, url };
                        updateExtractionStats(strategy, true, performance.now() - startTime, errors);
                        return result;
                    } else {
                        debugStep('Strategy 4: Generic CSS', false, `Found ${genericResult?.ingredients?.length || 0} ingredients, ${genericResult?.instructions?.length || 0} instructions`);
                    }
                } catch (error) {
                    errors.push(`Generic CSS: ${error.message}`);
                    debugStep('Strategy 4: Generic CSS', false, error.message);
                }
                
                // If all strategies fail, return a basic structure instead of undefined
                debugLog('All extraction strategies failed, returning basic structure', 'warning');
                updateExtractionStats('Failed', false, performance.now() - startTime, errors);
                
                return {
                    title: extractGenericTitle(doc) || 'Recipe from ' + domain,
                    description: extractMetaDescription(doc) || '',
                    image: extractGenericImage(doc) || '',
                    ingredients: ['Could not extract ingredients - please check the original recipe'],
                    instructions: ['Could not extract instructions - please check the original recipe'],
                    prepTime: '',
                    cookTime: '',
                    totalTime: '',
                    servings: '',
                    url: url
                };
                
            } catch (error) {
                debugLog(`Critical error in extraction: ${error.message}`, 'error');
                errors.push(`Critical: ${error.message}`);
                updateExtractionStats('Failed', false, performance.now() - startTime, errors);
                
                // Return a basic structure instead of throwing
                return {
                    title: 'Recipe Extraction Failed',
                    description: 'Could not extract recipe data',
                    image: '',
                    ingredients: ['Extraction failed - please check the original recipe'],
                    instructions: ['Extraction failed - please check the original recipe'],
                    prepTime: '',
                    cookTime: '',
                    totalTime: '',
                    servings: '',
                    url: url
                };
            }
        }

        // Try multiple CORS proxies until one works
        async function fetchWithFallback(url) {
            let lastError;
            
            for (let i = 0; i < CORS_PROXIES.length; i++) {
                const proxy = CORS_PROXIES[i];
                try {
                    debugLog(`Trying proxy ${i + 1}/${CORS_PROXIES.length}: ${proxy}`, 'info');
                    
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000); // Increased timeout
                    
                    const response = await fetch(proxy + encodeURIComponent(url), {
                        signal: controller.signal,
                        headers: {
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        const html = await response.text();
                        debugLog(`Proxy ${i + 1} successful (${response.status})`, 'success');
                        
                        // Debug the response
                        const isValidResponse = debugProxyResponse(html, url);
                        
                        if (isValidResponse) {
                            return html;
                        } else {
                            debugLog(`Proxy ${i + 1} returned blocked/empty content`, 'warning');
                            throw new Error('Blocked or empty response');
                        }
                    } else {
                        debugLog(`Proxy ${i + 1} failed with status: ${response.status}`, 'warning');
                    }
                } catch (error) {
                    debugLog(`Proxy ${i + 1} failed: ${error.message}`, 'warning');
                    lastError = error;
                }
            }
            
            throw new Error(`All CORS proxies failed. Last error: ${lastError?.message || 'Unknown error'}`);
        }

        // Strategy 1: JSON-LD structured data
        function extractFromJsonLD(doc) {
            debugLog('Searching for JSON-LD structured data...', 'info');
            
            if (!doc) {
                debugLog('No document provided to extractFromJsonLD', 'warning');
                return null;
            }
            
            try {
                const scripts = doc.querySelectorAll('script[type="application/ld+json"]');
                debugLog(`Found ${scripts.length} JSON-LD script tags`, 'info');
                
                for (let i = 0; i < scripts.length; i++) {
                    try {
                        debugLog(`Parsing JSON-LD script ${i + 1}/${scripts.length}`, 'info');
                        const data = JSON.parse(scripts[i].textContent);
                        debugLog('JSON-LD parsed successfully', 'success', {
                            type: data['@type'],
                            isArray: Array.isArray(data)
                        });
                        
                        const recipe = Array.isArray(data) ? 
                            data.find(item => item['@type'] === 'Recipe') : 
                            data['@type'] === 'Recipe' ? data : null;
                        
                        if (recipe) {
                            debugLog('Recipe object found in JSON-LD', 'success', {
                                hasName: !!recipe.name,
                                hasIngredients: !!recipe.recipeIngredient,
                                hasInstructions: !!recipe.recipeInstructions,
                                ingredientCount: recipe.recipeIngredient?.length || 0,
                                instructionCount: recipe.recipeInstructions?.length || 0,
                                hasTotalTime: !!recipe.totalTime,
                                hasYield: !!recipe.recipeYield
                            });
                            
                            return {
                                title: cleanText(recipe.name) || 'Untitled Recipe',
                                description: cleanText(recipe.description) || '',
                                image: extractImageFromData(recipe.image) || '',
                                ingredients: extractAndFilterIngredients(recipe.recipeIngredient || []),
                                instructions: extractAndFilterInstructions(
                                    recipe.recipeInstructions ? recipe.recipeInstructions.map(inst => 
                                        typeof inst === 'string' ? inst : inst.text || inst.name || ''
                                    ).filter(Boolean) : []
                                ),
                                prepTime: parseTimeData(recipe.prepTime) || '',
                                cookTime: parseTimeData(recipe.cookTime) || '',
                                totalTime: parseTimeData(recipe.totalTime) || '',
                                servings: parseServingData(recipe.recipeYield || recipe.yield) || ''
                            };
                        } else {
                            debugLog(`JSON-LD script ${i + 1} is not a recipe`, 'info');
                        }
                    } catch (e) {
                        debugLog(`Failed to parse JSON-LD script ${i + 1}: ${e.message}`, 'warning');
                    }
                }
            } catch (error) {
                debugLog(`Error in extractFromJsonLD: ${error.message}`, 'error');
            }
            
            return null;
        }

        // Helper functions for parsing structured data (with error handling)
        function parseTimeData(timeData) {
            if (!timeData) return '';
            
            try {
                if (typeof timeData === 'string') {
                    // Handle ISO 8601 duration format (PT30M, PT1H30M)
                    if (timeData.startsWith('PT')) {
                        const hours = (timeData.match(/(\d+)H/) || [0, 0])[1];
                        const minutes = (timeData.match(/(\d+)M/) || [0, 0])[1];
                        
                        if (hours && minutes) {
                            return `${hours}h ${minutes}m`;
                        } else if (hours) {
                            return `${hours}h`;
                        } else if (minutes) {
                            return `${minutes}m`;
                        }
                    }
                    
                    // Handle regular time text
                    return cleanTimeText(timeData);
                }
            } catch (error) {
                debugLog(`Error in parseTimeData: ${error.message}`, 'warning');
            }
            
            return '';
        }

        function parseServingData(servingData) {
            if (!servingData) return '';
            
            try {
                if (typeof servingData === 'number') {
                    return servingData.toString();
                }
                
                if (typeof servingData === 'string') {
                    return cleanServingText(servingData);
                }
                
                if (Array.isArray(servingData)) {
                    return cleanServingText(servingData[0]);
                }
            } catch (error) {
                debugLog(`Error in parseServingData: ${error.message}`, 'warning');
            }
            
            return '';
        }

        // Strategy 2: Domain-specific CSS selectors
        function extractFromDomainRules(doc, domain, html) {
            const rules = DOMAIN_RULES[domain];
            if (!rules) {
                debugLog(`No domain-specific rules found for: ${domain}`, 'info');
                return null;
            }

            if (!doc) {
                debugLog('No document provided to extractFromDomainRules', 'error');
                return null;
            }

            debugLog(`Using domain-specific rules for: ${domain}`, 'info', rules);

            try {
                const title = extractBySelectors(doc, rules.title, 'textContent');
                const ingredients = extractListBySelectors(doc, rules.ingredients);
                const instructions = extractListBySelectors(doc, rules.instructions);
                
                // Extract time and serving information (with null check for html)
                const timeAndServings = extractTimeAndServings(doc, html);

                debugLog('Domain-specific extraction results', 'info', {
                    title: !!title,
                    ingredientCount: ingredients.length,
                    instructionCount: instructions.length,
                    totalTime: timeAndServings.totalTime || 'Not found',
                    servings: timeAndServings.servings || 'Not found'
                });

                if (ingredients.length > 0 || instructions.length > 0) {
                    return {
                        title: cleanText(title) || extractGenericTitle(doc),
                        description: extractMetaDescription(doc),
                        image: extractGenericImage(doc),
                        ingredients: extractAndFilterIngredients(ingredients),
                        instructions: extractAndFilterInstructions(instructions),
                        prepTime: timeAndServings.prepTime || '',
                        cookTime: timeAndServings.cookTime || '',
                        totalTime: timeAndServings.totalTime || '',
                        servings: timeAndServings.servings || ''
                    };
                }
            } catch (error) {
                debugLog(`Error in extractFromDomainRules: ${error.message}`, 'error');
            }
            
            return null;
        }

        // Strategy 3: Enhanced text parsing
        function extractFromEnhancedText(html, doc) {
            debugLog('Starting enhanced text parsing...', 'info');
            
            if (!html || !doc) {
                debugLog('Missing html or doc parameter for enhanced text parsing', 'warning');
                return null;
            }
            
            try {
                // Clean HTML for text parsing
                const cleanHtml = html
                    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
                    .replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, '')
                    .replace(/<nav\b[^<]*(?:(?!<\/nav>)<[^<]*)*<\/nav>/gi, '')
                    .replace(/<header\b[^<]*(?:(?!<\/header>)<[^<]*)*<\/header>/gi, '')
                    .replace(/<footer\b[^<]*(?:(?!<\/footer>)<[^<]*)*<\/footer>/gi, '')
                    .replace(/<aside\b[^<]*(?:(?!<\/aside>)<[^<]*)*<\/aside>/gi, '');

                debugLog(`Cleaned HTML (${cleanHtml.length} characters)`, 'info');

                // Convert to plain text but preserve structure
                let textContent = cleanHtml
                    .replace(/<\/?(h[1-6]|p|div|li|ul|ol)[^>]*>/gi, '\n')
                    .replace(/<[^>]*>/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();

                // CRITICAL: Decode HTML entities
                textContent = textContent
                    .replace(/&#32;/g, ' ')
                    .replace(/&nbsp;/g, ' ')
                    .replace(/&#36;/g, '$')
                    .replace(/&amp;/g, '&')
                    .replace(/&lt;/g, '<')
                    .replace(/&gt;/g, '>')
                    .replace(/&quot;/g, '"');

                debugLog(`Extracted and decoded text content (${textContent.length} characters)`, 'info');

                let ingredients = [];
                let instructions = [];

                // Add debugging call
                debugTextParsing(html);
                
                // NEW APPROACH: Parse continuous text format from the FIRST sections (which have better structure)
                
                // Strategy 1: Extract ingredients from first section with improved parsing
                const firstIngredientsMatch = textContent.match(/Ingredients([^]*?)Instructions/i);
                if (firstIngredientsMatch) {
                    const ingredientsText = firstIngredientsMatch[1];
                    debugLog('Found first ingredients section, parsing...', 'info');
                    
                    // Use the new parsing function
                    ingredients = parseIngredientsFromText(ingredientsText);
                    debugLog(`Extracted ${ingredients.length} ingredients from first section`, 'success', ingredients.slice(0, 5));
                }

                // Strategy 2: Extract instructions from first section with improved parsing
                const firstInstructionsMatch = textContent.match(/Instructions([^]*?)(?:Notes|Tips|Nutrition|Related|$)/i);
                if (firstInstructionsMatch) {
                    const instructionsText = firstInstructionsMatch[1];
                    debugLog('Found first instructions section, parsing...', 'info');
                    
                    // Use the new parsing function
                    instructions = parseInstructionsFromText(instructionsText);
                    debugLog(`Extracted ${instructions.length} instructions from first section`, 'success', instructions.slice(0, 3));
                }

                // Extract time and serving information
                const timeAndServings = extractTimeAndServings(doc, html);

                debugLog('Enhanced text parsing results', 'info', {
                    ingredientCount: ingredients.length,
                    instructionCount: instructions.length,
                    sampleIngredients: ingredients.slice(0, 3),
                    sampleInstructions: instructions.slice(0, 3)
                });

                if (ingredients.length > 0 || instructions.length > 0) {
                    return {
                        title: extractGenericTitle(doc),
                        description: extractMetaDescription(doc),
                        image: extractGenericImage(doc),
                        ingredients: extractAndFilterIngredients(ingredients),
                        instructions: extractAndFilterInstructions(instructions),
                        prepTime: timeAndServings.prepTime || '',
                        cookTime: timeAndServings.cookTime || '',
                        totalTime: timeAndServings.totalTime || '',
                        servings: timeAndServings.servings || ''
                    };
                }
                
            } catch (error) {
                debugLog(`Error in extractFromEnhancedText: ${error.message}`, 'error');
            }
            
            return null;
        }

        function parseIngredientsFromText(text) {
            const ingredients = [];
            
            try {
                debugLog('Parsing ingredients from enhanced text...', 'info');
                
                // Method 1: Look for ingredient sections with better patterns
                const ingredientSectionPatterns = [
                    /Ingredients([^]*?)(?:Instructions|Directions|Method|For the Steak|For the Lobster|$)/i,
                    /For the [^:]*:([^]*?)(?:For the|Instructions|Directions|$)/gi
                ];
                
                for (const pattern of ingredientSectionPatterns) {
                    const matches = text.match(pattern);
                    if (matches) {
                        debugLog(`Found ingredient section with pattern`, 'success');
                        
                        if (pattern.global) {
                            // Handle multiple "For the X:" sections
                            matches.forEach(match => {
                                const sectionIngredients = extractIngredientsFromSection(match);
                                ingredients.push(...sectionIngredients);
                            });
                        } else {
                            // Handle single ingredients section
                            const sectionIngredients = extractIngredientsFromSection(matches[1]);
                            ingredients.push(...sectionIngredients);
                        }
                    }
                }
                
                // Method 2: Look for list patterns throughout the text
                if (ingredients.length < 5) {
                    debugLog('Trying broader ingredient patterns...', 'info');
                    const broadIngredients = extractIngredientsFromBroadPatterns(text);
                    ingredients.push(...broadIngredients);
                }
                
                debugLog(`Extracted ${ingredients.length} ingredients total`, 'success', ingredients.slice(0, 5));
                
            } catch (error) {
                debugLog(`Error parsing ingredients: ${error.message}`, 'error');
            }
            
            return [...new Set(ingredients)]; // Remove duplicates
        }

        function extractIngredientsFromSection(sectionText) {
            const ingredients = [];
            
            // Split by lines and clean
            const lines = sectionText.split(/\n+/)
                .map(line => line.trim())
                .filter(line => line.length > 3);
            
            for (const line of lines) {
                // Skip headers
                if (line.match(/^(For the|Ingredients|Instructions)/i)) continue;
                
                // Look for ingredient patterns - be more permissive
                const patterns = [
                    /^\d+.*(?:oz|ounce|pound|lb|cup|tablespoon|teaspoon|tsp|tbsp|clove|steak|tail)/i,
                    /^\d+\s+\w+.*(?:salt|pepper|butter|garlic|lemon|rosemary|thyme|parsley|chives)/i,
                    /^[^\d]*(?:salt|pepper|butter|garlic|lemon|rosemary|thyme|parsley|chives|steak|lobster|filet)/i
                ];
                
                const isIngredient = patterns.some(pattern => pattern.test(line)) ||
                    line.match(/\b(?:oz|ounce|pound|lb|cup|tablespoon|teaspoon|tsp|tbsp|clove|minced|chopped|fresh|unsalted)\b/i);
                
                if (isIngredient && line.length > 5 && line.length < 200) {
                    const cleaned = line.replace(/^[-•*]\s*/, '').trim();
                    if (cleaned) {
                        ingredients.push(cleaned);
                    }
                }
            }
            
            return ingredients;
        }

        function extractIngredientsFromBroadPatterns(text) {
            const ingredients = [];
            
            // Split entire text and look for ingredient-like lines
            const allLines = text.split(/\n+/)
                .map(line => line.trim())
                .filter(line => line.length > 5 && line.length < 200);
            
            for (const line of allLines) {
                // Skip obvious non-ingredients
                if (line.match(/^(Instructions|Directions|Method|Notes|Tips|Total Time|Prep Time|Cook Time|Servings)/i)) continue;
                
                // Look for strong ingredient indicators
                const hasStrongIndicators = line.match(/\b(?:\d+\s*(?:oz|ounce|pound|lb|cup|tablespoon|teaspoon|tsp|tbsp|clove)|salt|pepper|butter|garlic|lemon|rosemary|thyme|parsley|chives|steak|lobster|filet)\b/i);
                
                if (hasStrongIndicators) {
                    const cleaned = line.replace(/^[-•*\d.\s]*/, '').trim();
                    if (cleaned && !ingredients.some(ing => ing.toLowerCase().includes(cleaned.toLowerCase()))) {
                        ingredients.push(cleaned);
                    }
                }
            }
            
            return ingredients;
        }

        function parseInstructionsFromText(text) {
            const instructions = [];
            
            try {
                debugLog('Parsing instructions from enhanced text...', 'info');
                
                // Method 1: Look for instructions section
                const instructionSectionMatch = text.match(/Instructions([^]*?)(?:Notes|Tips|Nutrition|Related|$)/i);
                if (instructionSectionMatch) {
                    debugLog('Found instructions section', 'success');
                    const sectionInstructions = extractInstructionsFromSection(instructionSectionMatch[1]);
                    instructions.push(...sectionInstructions);
                }
                
                // Method 2: Look for numbered or bulleted instruction patterns
                if (instructions.length < 5) {
                    debugLog('Trying broader instruction patterns...', 'info');
                    const broadInstructions = extractInstructionsFromBroadPatterns(text);
                    instructions.push(...broadInstructions);
                }
                
                debugLog(`Extracted ${instructions.length} instructions total`, 'success', instructions.slice(0, 3));
                
            } catch (error) {
                debugLog(`Error parsing instructions: ${error.message}`, 'error');
            }
            
            return instructions;
        }

        function extractInstructionsFromSection(sectionText) {
            const instructions = [];
            
            // Split by lines and clean
            const lines = sectionText.split(/\n+/)
                .map(line => line.trim())
                .filter(line => line.length > 15);
            
            for (const line of lines) {
                // Skip headers
                if (line.match(/^(Instructions|Directions|Method|Notes|Tips)/i)) continue;
                
                // Look for instruction patterns
                const hasCookingWords = line.match(/\b(?:season|preheat|grill|cook|heat|place|serve|butterfly|drizzle|garnish|allow|form|squeeze|plate|minutes|degrees|combine|mix|refrigerate|sear|sides|doneness|melt|infuse)\b/i);
                const isReasonableLength = line.length >= 20 && line.length <= 500;
                
                if (hasCookingWords && isReasonableLength) {
                    const cleaned = line.replace(/^[-•*\d.\s]*/, '').trim();
                    if (cleaned) {
                        instructions.push(cleaned);
                    }
                }
            }
            
            return instructions;
        }

        function extractInstructionsFromBroadPatterns(text) {
            const instructions = [];
            
            // Split entire text and look for instruction-like sentences
            const allLines = text.split(/\n+/)
                .map(line => line.trim())
                .filter(line => line.length > 20 && line.length < 500);
            
            for (const line of allLines) {
                // Skip obvious non-instructions
                if (line.match(/^(Ingredients|For the|Notes|Tips|Nutrition|Total Time|Prep Time|Cook Time|Servings)/i)) continue;
                
                // Look for strong instruction indicators
                const hasStrongIndicators = line.match(/\b(?:season|preheat|grill|cook|heat|place|serve|butterfly|drizzle|garnish|allow|form|squeeze|plate|combine|mix|refrigerate|sear|doneness|melt|infuse|minutes|degrees|sides|until)\b/i);
                const startsWithAction = line.match(/^(?:Season|Preheat|Grill|Cook|Heat|Place|Serve|Butterfly|Drizzle|Garnish|Allow|Form|Squeeze|Plate|Combine|Mix|Refrigerate|In a|During|About)/i);
                
                if (hasStrongIndicators || startsWithAction) {
                    const cleaned = line.replace(/^[-•*\d.\s]*/, '').trim();
                    if (cleaned && !instructions.some(inst => inst.toLowerCase().includes(cleaned.toLowerCase().substring(0, 30)))) {
                        instructions.push(cleaned);
                    }
                }
            }
            
            return instructions;
        }

        function parseIngredientSection(section) {
            const lines = section.split(/\n+/)
                .map(line => line.trim())
                .filter(line => line.length > 3);
            
            const ingredients = [];
            for (const line of lines) {
                // Skip section headers
                if (line.match(/^For the/i) || line.match(/^(Instructions|Directions|Method):/i)) continue;
                
                // Look for ingredient patterns
                if (line.match(/^\d+|[-•]/) || 
                    line.match(/\b(?:cup|tablespoon|teaspoon|pound|ounce|gram|tsp|tbsp|lb|oz|clove|slice)\b/i) ||
                    line.match(/\b(?:salt|pepper|garlic|butter|oil|sugar|flour|cheese|onion|lemon)\b/i)) {
                    const cleanLine = line.replace(/^[-•\d\s]*/, '').trim();
                    if (cleanLine.length > 3) {
                        ingredients.push(cleanLine);
                    }
                }
            }
            
            return ingredients;
        }

        function parseInstructionSection(section) {
            const lines = section.split(/\n+/)
                .map(line => line.trim())
                .filter(line => line.length > 10);
            
            const instructions = [];
            for (const line of lines) {
                // Skip obvious non-instructions
                if (line.match(/^(Ingredients|For the|Tried this recipe|Notes|Tips)/i)) continue;
                
                // Look for instruction patterns - be more permissive
                const hasInstructionWords = line.match(/\b(?:heat|cook|add|mix|grill|bake|season|place|serve|prepare|cut|slice|combine|stir|remove|butterfly|drizzle|garnish|allow|form|squeeze|plate|preheat|minutes|degrees|until|about|during)\b/i);
                const hasGoodLength = line.length >= 15 && line.length <= 500;
                const isNotObviousIngredient = !line.match(/^[\d\s]*(?:cup|tsp|tbsp|oz|lb|ounce|pound|clove|slice)/i);
                
                if (hasInstructionWords && hasGoodLength && isNotObviousIngredient) {
                    const cleanLine = line.replace(/^[-•\d\s]*/, '').trim();
                    instructions.push(cleanLine);
                }
            }
            
            return instructions;
        }

        // Parse ingredients from text
        function parseTextIngredients(text) {
            debugLog('Parsing ingredients from text...', 'info');
            
            // Split on newlines and clean up
            const lines = text.split(/\n+/)
                .map(line => cleanText(line))
                .filter(line => line.length > 2);

            debugLog(`Found ${lines.length} potential ingredient lines`, 'info', {
                firstFew: lines.slice(0, 5)
            });

            const ingredients = [];
            for (const line of lines) {
                // Skip obvious non-ingredients
                if (line.match(/^(ingredients?|instructions?|directions?|notes?|tips?|method|equipment|nutrition|recipe|print|save|prep time|cook time|total time|servings|calories)$/i)) continue;
                if (line.length > 200) continue; // Skip long paragraphs
                if (line.length < 5) continue; // Skip very short lines
                
                // Look for ingredient patterns (more permissive)
                const hasNumber = line.match(/^\d+|[\d\/\-\.]+/); // Starts with number or contains fractions
                const hasMeasurement = line.match(/\b(?:cup|tablespoon|teaspoon|pound|ounce|gram|liter|tsp|tbsp|lb|oz|kg|g|ml|l|clove|slice|dash|pinch|can|jar|package|pkg|head|bunch|medium|large|small)\b/i);
                const hasFoodWords = line.match(/\b(?:oil|salt|pepper|onion|garlic|butter|cheese|flour|sugar|egg|milk|water|sauce|spice|herb|chicken|beef|pork|fish|tomato|potato|carrot|celery|rice|pasta|bread|cream|wine|broth|stock|lemon|lime|apple|banana|spinach|lettuce|mushroom|bell|chili|paprika|oregano|basil|thyme|rosemary|cilantro|parsley|ginger|vinegar|honey|olive|vegetable|canola|coconut|vanilla|chocolate|nuts|almonds|cashews|walnuts|pecans)\b/i);
                
                if (hasNumber || hasMeasurement || hasFoodWords) {
                    ingredients.push(line);
                }
            }
            
            debugLog(`Extracted ${ingredients.length} ingredients from text`, 'info', {
                ingredients: ingredients.slice(0, 5)
            });
            return ingredients;
        }

        function debugTextParsing(html) {
            console.group('🔍 TEXT PARSING DEBUG');
            
            // Show first part of cleaned text
            const cleanHtml = html
                .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
                .replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, '');
            
            let textContent = cleanHtml
                .replace(/<\/?(h[1-6]|p|div|li|ul|ol)[^>]*>/gi, '\n')
                .replace(/<[^>]*>/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
            
            console.log('Raw text sample (first 1000 chars):', textContent.substring(0, 1000));
            
            // Look for ingredient section
            const ingredientMatch = textContent.match(/Ingredients([^]*?)Instructions/i);
            if (ingredientMatch) {
                console.log('Found ingredient section:', ingredientMatch[1].substring(0, 500));
            }
            
            // Look for instruction section  
            const instructionMatch = textContent.match(/Instructions([^]*?)(?:Notes|Tips|$)/i);
            if (instructionMatch) {
                console.log('Found instruction section:', instructionMatch[1].substring(0, 800));
            }
            
            console.groupEnd();
        }

        // Parse instructions from text  
        function parseTextInstructions(text) {
            debugLog('Parsing instructions from text...', 'info');
            
            // Split on newlines and clean up
            const lines = text.split(/\n+/)
                .map(line => cleanText(line))
                .filter(line => line.length > 15);

            debugLog(`Found ${lines.length} potential instruction lines`, 'info', {
                firstFew: lines.slice(0, 3)
            });

            const instructions = [];
            for (const line of lines) {
                // Skip headers
                if (line.match(/^(ingredients?|instructions?|directions?|notes?|tips?|method|equipment|nutrition|recipe|print|save|prep time|cook time|total time|servings|calories)$/i)) continue;
                
                // Look for instruction patterns (more permissive)
                const hasCookingWords = line.match(/\b(?:add|mix|stir|cook|bake|heat|boil|preheat|combine|place|pour|serve|garnish|season|sear|brown|saute|simmer|cover|remove|chop|dice|slice|mince|cut|blend|whisk|beat|fold|toss|sprinkle|drizzle|marinate|roast|broil|grill|fry|steam|reduce|thicken|melt|soften|tender|golden|crispy|bubbling|until|degrees|minutes|hours|oven|skillet|pan|pot|bowl|dish)\b/i);
                const hasSequentialWords = line.match(/\b(?:first|then|next|finally|meanwhile|while|after|before|once|when|until|step|continue|repeat)\b/i);
                const isReasonableLength = line.length >= 20 && line.length <= 500;
                
                if ((hasCookingWords || hasSequentialWords) && isReasonableLength) {
                    instructions.push(line);
                }
            }
            
            debugLog(`Extracted ${instructions.length} instructions from text`, 'info', {
                instructions: instructions.slice(0, 3)
            });
            return instructions;
        }

        // Strategy 4: Generic CSS selectors
        function extractFromGenericSelectors(doc, html) {
            debugLog('Using generic CSS selectors...', 'info');
            
            if (!doc) {
                debugLog('No document provided to extractFromGenericSelectors', 'error');
                return createFailsafeRecipe('Error: No document provided');
            }
            
            try {
                // FIXED: Only use valid CSS selectors (removed :contains() selectors)
                const ingredientSelectors = [
                    '.recipe-card-ingredients li', '.wp-block-recipe-card-ingredients li',
                    '.recipe-ingredients li', '.ingredients li', 'li[class*="ingredient"]',
                    '.recipe-ingredient', '.ingredient', '[class*="ingredient"]',
                    '.entry-content ul li', '.post-content ul li',
                    'ul li' // Very generic fallback
                ];
                
                const instructionSelectors = [
                    '.recipe-card-instructions li', '.wp-block-recipe-card-instructions li',
                    '.recipe-instructions li', '.instructions li', 'li[class*="instruction"]',
                    '.recipe-instruction', '.instruction', '[class*="instruction"]',
                    '.method-step', '.recipe-step', '.directions li',
                    '.entry-content ol li', '.post-content ol li',
                    'ol li' // Very generic fallback
                ];

                let ingredients = extractListBySelectors(doc, ingredientSelectors);
                let instructions = extractListBySelectors(doc, instructionSelectors);
                
                // If still no ingredients/instructions, try scanning ALL text content
                if (ingredients.length === 0 || instructions.length === 0) {
                    debugLog('Scanning all page content for recipe data...', 'info');
                    const pageContent = doc.body ? doc.body.textContent : doc.textContent || '';
                    debugLog(`Total page content length: ${pageContent.length}`, 'info');
                    
                    if (pageContent.length > 100) {
                        const parsed = parsePageContent(pageContent);
                        if (parsed.ingredients.length > ingredients.length) {
                            ingredients = parsed.ingredients;
                        }
                        if (parsed.instructions.length > instructions.length) {
                            instructions = parsed.instructions;
                        }
                    }
                }
                
                // Extract time and serving information
                const timeAndServings = extractTimeAndServings(doc, html);

                debugLog('Generic selector results', 'info', {
                    ingredientCount: ingredients.length,
                    instructionCount: instructions.length,
                    sampleIngredients: ingredients.slice(0, 3),
                    sampleInstructions: instructions.slice(0, 2)
                });

                return {
                    title: extractGenericTitle(doc),
                    description: extractMetaDescription(doc),
                    image: extractGenericImage(doc),
                    ingredients: extractAndFilterIngredients(ingredients),
                    instructions: extractAndFilterInstructions(instructions),
                    prepTime: timeAndServings.prepTime || '',
                    cookTime: timeAndServings.cookTime || '',
                    totalTime: timeAndServings.totalTime || '',
                    servings: timeAndServings.servings || ''
                };
            } catch (error) {
                debugLog(`Error in extractFromGenericSelectors: ${error.message}`, 'error');
                return createFailsafeRecipe('Error extracting recipe data');
            }
        }

        // Helper functions
        function parsePageContent(pageContent) {
            const ingredients = [];
            const instructions = [];
            
            try {
                // Look for ingredient patterns in the entire page text
                const lines = pageContent.split(/\n+/).map(line => line.trim()).filter(line => line.length > 3);
                
                let inIngredientsSection = false;
                let inInstructionsSection = false;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const nextLine = lines[i + 1] || '';
                    
                    // Check for section headers
                    if (line.match(/^(Ingredients|For the)/i)) {
                        inIngredientsSection = true;
                        inInstructionsSection = false;
                        continue;
                    }
                    
                    if (line.match(/^(Instructions|Directions|Method|Prepare|Steps)/i)) {
                        inInstructionsSection = true;
                        inIngredientsSection = false;
                        continue;
                    }
                    
                    // Look for ingredient patterns
                    if (inIngredientsSection || 
                        line.match(/^[-•]\s*\d+.*(?:cup|tsp|tbsp|oz|lb|clove|slice|steak|lobster|butter|salt|pepper)/i)) {
                        const cleanLine = line.replace(/^[-•\s]*/, '').trim();
                        if (cleanLine.length > 5 && cleanLine.length < 200) {
                            ingredients.push(cleanLine);
                        }
                    }
                    
                    // Look for instruction patterns
                    if (inInstructionsSection || 
                        line.match(/\b(?:season|preheat|grill|cook|heat|place|serve|butterfly|drizzle|garnish)\b/i)) {
                        if (line.length > 20 && line.length < 500) {
                            const cleanLine = line.replace(/^[-•\d\s]*/, '').trim();
                            instructions.push(cleanLine);
                        }
                    }
                    
                    // Stop at certain keywords
                    if (line.match(/^(Notes|Tips|Nutrition|Related|Share)/i)) {
                        break;
                    }
                }
                
            } catch (error) {
                debugLog(`Error parsing page content: ${error.message}`, 'warning');
            }
            
            return { ingredients, instructions };
        }

        function createFailsafeRecipe(errorMsg) {
            return {
                title: 'Recipe Extraction Failed',
                description: 'Could not extract recipe data from this site',
                image: '',
                ingredients: [errorMsg, 'Please check the original recipe link'],
                instructions: ['Visit the original recipe for instructions'],
                prepTime: '',
                cookTime: '',
                totalTime: '',
                servings: ''
            };
        }

        function extractBySelectors(doc, selectors, property = 'textContent') {
            for (const selector of selectors) {
                const element = doc.querySelector(selector);
                if (element) {
                    debugLog(`Found element with selector: ${selector}`, 'success');
                    return property === 'textContent' ? element.textContent : element[property];
                }
            }
            debugLog(`No elements found for selectors: ${selectors.join(', ')}`, 'warning');
            return '';
        }

        function extractListBySelectors(doc, selectors) {
            for (const selector of selectors) {
                const elements = doc.querySelectorAll(selector);
                if (elements.length > 0) {
                    debugLog(`Found ${elements.length} elements with selector: ${selector}`, 'success');
                    const results = Array.from(elements).map(el => el.textContent.trim()).filter(Boolean);
                    
                    // Check if we got large blocks that need to be split
                    const splitResults = [];
                    for (const result of results) {
                        if (result.length > 300 && result.includes('\n')) {
                            // This looks like a combined block - try to split it
                            debugLog(`Splitting combined content block (${result.length} chars)`, 'info');
                            const splitItems = splitCombinedContent(result, selector.includes('ingredient'));
                            splitResults.push(...splitItems);
                        } else {
                            splitResults.push(result);
                        }
                    }
                    
                    debugLog(`After splitting: ${splitResults.length} items`, 'info', {
                        firstFew: splitResults.slice(0, 3)
                    });
                    
                    return splitResults;
                }
            }
            debugLog(`No list elements found for selectors: ${selectors.join(', ')}`, 'warning');
            return [];
        }

        function splitCombinedContent(text, isIngredient) {
            // Remove header text and clean up
            const cleaned = text
                .replace(/^(ingredients?|instructions?|directions?|method|cook mode|prevent your screen from going dark)/i, '')
                .replace(/last step!.*$/i, '') // Remove footer text
                .trim();
            
            // Split on newlines and filter
            const lines = cleaned.split(/\n+/)
                .map(line => line.trim())
                .filter(line => {
                    if (!line || line.length < 3) return false;
                    if (line.match(/^(ingredients?|instructions?|directions?|method|cook mode|prevent your screen|last step|please leave a review)/i)) return false;
                    return true;
                });
            
            if (isIngredient) {
                // For ingredients, look for lines that seem like individual ingredients
                return lines.filter(line => {
                    return line.length >= 5 && line.length <= 150 && 
                           (line.match(/\d/) || line.match(/\b(?:cup|tsp|tbsp|pound|lb|oz|clove|slice|dash|pinch|can|jar|package)\b/i));
                });
            } else {
                // For instructions, look for lines that seem like individual steps
                return lines.filter(line => {
                    return line.length >= 20 && line.length <= 400;
                });
            }
        }

        function extractGenericTitle(doc) {
            if (!doc) return 'Untitled Recipe';
            
            // Try multiple title sources in order of preference
            const titleSources = [
                () => doc.querySelector('h1.entry-title')?.textContent,
                () => doc.querySelector('h1.post-title')?.textContent,
                () => doc.querySelector('h1[class*="title"]')?.textContent,
                () => doc.querySelector('.recipe-title')?.textContent,
                () => doc.querySelector('h1')?.textContent,
                () => doc.querySelector('title')?.textContent,
                () => doc.querySelector('meta[property="og:title"]')?.content
            ];
            
            for (const getTitle of titleSources) {
                try {
                    const title = getTitle();
                    if (title && title.trim().length > 0) {
                        const cleanTitle = cleanText(title);
                        if (cleanTitle && cleanTitle !== 'Untitled Recipe') {
                            debugLog(`Extracted title: ${cleanTitle}`, 'info');
                            return cleanTitle;
                        }
                    }
                } catch (e) {
                    // Continue to next title source
                }
            }
            
            debugLog('No title found, using fallback', 'warning');
            return 'Untitled Recipe';
        }

        function debugProxyResponse(html, url) {
            console.group('🔍 PROXY RESPONSE DEBUG');
            console.log('URL:', url);
            console.log('HTML Length:', html.length);
            console.log('First 500 characters:', html.substring(0, 500));
            console.log('Contains title tag:', html.includes('<title>'));
            console.log('Contains body tag:', html.includes('<body>'));
            console.log('Contains script tags:', html.includes('<script>'));
            console.log('Looks like error page:', html.includes('error') || html.includes('404') || html.includes('access denied'));
            console.groupEnd();
            
            // If HTML is suspiciously short, it's likely blocked
            if (html.length < 1000) {
                debugLog('⚠️ HTML content suspiciously short - proxy may be blocked', 'warning');
                return false;
            }
            return true;
        }

        function extractMetaDescription(doc) {
            const description = doc.querySelector('meta[name="description"]')?.content || '';
            debugLog(`Extracted description: ${description ? 'Found' : 'Not found'}`, 'info');
            return description;
        }

        function extractGenericImage(doc) {
            const image = doc.querySelector('meta[property="og:image"]')?.content || 
                   doc.querySelector('.recipe-image img')?.src || 
                   doc.querySelector('img[class*="recipe"]')?.src || '';
            debugLog(`Extracted image: ${image ? 'Found' : 'Not found'}`, 'info');
            return image;
        }

        function extractImageFromData(image) {
            if (!image) return '';
            if (typeof image === 'string') return image;
            if (Array.isArray(image)) return image[0] || '';
            return image.url || image['@id'] || '';
        }

        function cleanText(text) {
            if (!text) return '';
            return text
                .replace(/▢/g, '') // Remove checkbox characters
                .replace(/\s+/g, ' ') // Replace multiple spaces with single space
                .replace(/^\d+\.\s*/, '') // Remove leading numbers like "1. "
                .trim();
        }

        // Essential filtering functions
        function extractAndFilterIngredients(ingredients) {
            debugLog(`Filtering ${ingredients.length} raw ingredients...`, 'info');
            const seen = new Set();
            const filtered = [];
            let skipped = 0;
            const skippedReasons = {};
            
            for (const ingredient of ingredients) {
                const cleaned = cleanText(ingredient);
                
                // Skip if empty or too short
                if (!cleaned || cleaned.length < 3) {
                    skipped++;
                    skippedReasons['too short'] = (skippedReasons['too short'] || 0) + 1;
                    continue;
                }
                
                // Skip obvious headers, navigation text, or multipliers
                if (cleaned.toLowerCase().match(/^(ingredients?|step photos|full ingredients|skip to|order|cookbook|salt.*lavender|0\.5x|1x|2x|3x|print|save|recipe|nutrition|notes|instructions|directions|method|prep time|cook time|total time|servings|calories|cook mode|prevent your screen)$/i)) {
                    skipped++;
                    skippedReasons['header/navigation'] = (skippedReasons['header/navigation'] || 0) + 1;
                    continue;
                }
                if (cleaned.match(/skip to|cookbook|order|salt.*lavender|step photos|full ingredients|amp|0\.5x1x2x3x|print recipe|save recipe|cook mode|prevent your screen/i)) {
                    skipped++;
                    skippedReasons['website text'] = (skippedReasons['website text'] || 0) + 1;
                    continue;
                }
                
                // More lenient length check - allow longer ingredients that were split from blocks
                if (cleaned.length > 400) {
                    skipped++;
                    skippedReasons['too long'] = (skippedReasons['too long'] || 0) + 1;
                    continue;
                }
                
                // More permissive validation - check for ANY food-related content
                const hasNumber = cleaned.match(/\d/);
                const hasMeasurement = cleaned.match(/\b(?:cup|tablespoon|teaspoon|pound|ounce|gram|liter|tsp|tbsp|lb|oz|kg|g|ml|l|clove|slice|dash|pinch|can|jar|package|pkg|head|bunch|medium|large|small|whole|half|quarter)\b/i);
                const hasFoodWords = cleaned.match(/\b(?:oil|salt|pepper|onion|garlic|butter|cheese|flour|sugar|egg|milk|water|sauce|spice|herb|chicken|beef|pork|fish|tomato|potato|carrot|celery|rice|pasta|bread|cream|wine|broth|stock|lemon|lime|apple|banana|spinach|lettuce|mushroom|bell|chili|paprika|oregano|basil|thyme|rosemary|cilantro|parsley|ginger|vinegar|honey|olive|vegetable|canola|coconut|vanilla|chocolate|nuts|almonds|cashews|walnuts|pecans|beans|corn|quinoa|barley|oats|avocado|bone-in|boneless|chops)\b/i);
                const seemsLikeIngredient = cleaned.length >= 5 && cleaned.length <= 200;
                
                // Accept if it has any food indicators OR seems reasonable
                if (!hasNumber && !hasMeasurement && !hasFoodWords && !seemsLikeIngredient) {
                    skipped++;
                    skippedReasons['no food pattern'] = (skippedReasons['no food pattern'] || 0) + 1;
                    continue;
                }
                
                // Skip if it's just a fragment of another ingredient we already have
                const isFragment = filtered.some(existing => 
                    existing.toLowerCase().includes(cleaned.toLowerCase()) && 
                    existing.length > cleaned.length + 10
                );
                if (isFragment) {
                    skipped++;
                    skippedReasons['duplicate fragment'] = (skippedReasons['duplicate fragment'] || 0) + 1;
                    continue;
                }
                
                // Deduplicate
                const normalized = cleaned.toLowerCase().replace(/[^\w\s]/g, '');
                if (seen.has(normalized)) {
                    skipped++;
                    skippedReasons['duplicate'] = (skippedReasons['duplicate'] || 0) + 1;
                    continue;
                }
                seen.add(normalized);
                
                filtered.push(cleaned);
                
                // Limit to reasonable number
                if (filtered.length >= 20) break;
            }
            
            debugLog(`Ingredient filtering complete: ${filtered.length} kept, ${skipped} skipped`, 'info', {
                skippedReasons,
                keptIngredients: filtered.slice(0, 5)
            });
            
            return filtered.length > 0 ? filtered : ['No ingredients found'];
        }

        function extractAndFilterInstructions(instructions) {
            debugLog(`Filtering ${instructions.length} raw instructions...`, 'info');
            const seen = new Set();
            const filtered = [];
            let skipped = 0;
            const skippedReasons = {};
            
            for (const instruction of instructions) {
                const cleaned = cleanText(instruction);
                
                // Skip if empty or too short for an instruction
                if (!cleaned || cleaned.length < 10) {
                    skipped++;
                    skippedReasons['too short'] = (skippedReasons['too short'] || 0) + 1;
                    continue;
                }
                
                // Skip obvious headers
                if (cleaned.toLowerCase().match(/^(ingredients?|instructions?|directions?|notes?|tips?|method|equipment|nutrition|recipe|print|save|prep time|cook time|total time|servings|calories|cook mode|prevent your screen)$/i)) {
                    skipped++;
                    skippedReasons['header'] = (skippedReasons['header'] || 0) + 1;
                    continue;
                }
                
                // Skip if it contains navigation/website text
                if (cleaned.match(/skip to|cookbook|order|salt.*lavender|step photos|full ingredients|amp|print recipe|save recipe|cook mode|prevent your screen|please leave a review|this helps our business/i)) {
                    skipped++;
                    skippedReasons['website text'] = (skippedReasons['website text'] || 0) + 1;
                    continue;
                }
                
                // More permissive - check for cooking words OR reasonable length
                const hasCookingWords = cleaned.match(/\b(?:add|mix|stir|cook|bake|heat|boil|preheat|combine|place|pour|serve|garnish|season|oven|skillet|pan|dish|minutes|degrees|temperature|sear|brown|saute|simmer|cover|remove|chop|dice|slice|mince|cut|blend|whisk|beat|fold|toss|sprinkle|drizzle|marinate|roast|broil|grill|fry|steam|reduce|thicken|melt|soften|tender|golden|crispy|bubbling|until|first|then|next|finally|meanwhile|while|after|before|once|when|step|continue|repeat|deglaze|register|thermometer|browned|stirring)\b/i);
                const isReasonableLength = cleaned.length >= 15 && cleaned.length <= 800;
                const hasNumbers = cleaned.match(/\d+/);
                
                // Accept if it seems like an instruction
                if (!hasCookingWords && (!isReasonableLength || !hasNumbers)) {
                    skipped++;
                    skippedReasons['no cooking pattern'] = (skippedReasons['no cooking pattern'] || 0) + 1;
                    continue;
                }
                
                // Deduplicate
                const normalized = cleaned.toLowerCase().replace(/[^\w\s]/g, '');
                if (seen.has(normalized)) {
                    skipped++;
                    skippedReasons['duplicate'] = (skippedReasons['duplicate'] || 0) + 1;
                    continue;
                }
                seen.add(normalized);
                
                filtered.push(cleaned);
                
                // Limit to reasonable number
                if (filtered.length >= 15) break;
            }
            
            debugLog(`Instruction filtering complete: ${filtered.length} kept, ${skipped} skipped`, 'info', {
                skippedReasons,
                keptInstructions: filtered.slice(0, 3)
            });
            
            return filtered.length > 0 ? filtered : ['No instructions found'];
        }

        function extractTimeAndServings(doc, html) {
            const result = {
                prepTime: '',
                cookTime: '',
                totalTime: '',
                servings: ''
            };
            
            if (!doc) {
                debugLog('No document provided for time/serving extraction', 'warning');
                return result;
            }
            
            try {
                // Try to extract time information
                result.totalTime = extractTotalTime(doc, html);
                result.servings = extractServings(doc, html);
            } catch (error) {
                debugLog(`Error in extractTimeAndServings: ${error.message}`, 'warning');
            }
            
            return result;
        }

        function extractTotalTime(doc, html) {
            if (!doc) return '';
            
            try {
                // Strategy 1: Look for common time selectors
                const timeSelectors = [
                    '.recipe-time-total',
                    '.total-time',
                    '.recipe-duration',
                    '[class*="total-time"]',
                    '[class*="duration"]',
                    '.prep-time + .cook-time',
                ];
                
                for (const selector of timeSelectors) {
                    const element = doc.querySelector(selector);
                    if (element) {
                        const timeText = cleanTimeText(element.textContent);
                        if (timeText) {
                            debugLog(`Found total time with selector ${selector}: ${timeText}`, 'success');
                            return timeText;
                        }
                    }
                }
                
                // Strategy 2: Look for time patterns in text (only if html is provided)
                if (html && typeof html === 'string') {
                    const timePatterns = [
                        /total:?\s*(\d+\s*(?:hours?|hrs?|h)?\s*\d*\s*(?:minutes?|mins?|m)?)/i,
                        /(?:total\s*time|duration|takes?):?\s*(\d+\s*(?:hours?|hrs?|h)?\s*\d*\s*(?:minutes?|mins?|m)?)/i,
                        /(\d+\s*(?:hours?|hrs?|h)\s*\d*\s*(?:minutes?|mins?|m)?)\s*(?:total|prep\s*&\s*cook)/i
                    ];
                    
                    const textContent = html.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ');
                    
                    for (const pattern of timePatterns) {
                        const match = textContent.match(pattern);
                        if (match) {
                            const timeText = cleanTimeText(match[1]);
                            if (timeText) {
                                debugLog(`Found total time with pattern: ${timeText}`, 'success');
                                return timeText;
                            }
                        }
                    }
                }
                
                // Strategy 3: Add prep + cook if both are found separately
                const prepTime = extractSpecificTime(doc, html, 'prep');
                const cookTime = extractSpecificTime(doc, html, 'cook');
                
                if (prepTime && cookTime) {
                    const total = addTimes(prepTime, cookTime);
                    if (total) {
                        debugLog(`Calculated total time from prep + cook: ${total}`, 'success');
                        return total;
                    }
                }
            } catch (error) {
                debugLog(`Error in extractTotalTime: ${error.message}`, 'warning');
            }
            
            return '';
        }

        function extractSpecificTime(doc, html, timeType) {
            if (!doc) return '';
            
            try {
                const selectors = [
                    `.${timeType}-time`,
                    `[class*="${timeType}-time"]`,
                    `[class*="${timeType}Time"]`
                ];
                
                for (const selector of selectors) {
                    const element = doc.querySelector(selector);
                    if (element) {
                        const timeText = cleanTimeText(element.textContent);
                        if (timeText) return timeText;
                    }
                }
                
                // Only try text parsing if html is provided and is a string
                if (html && typeof html === 'string') {
                    const pattern = new RegExp(`${timeType}:?\\s*(\\d+\\s*(?:hours?|hrs?|h)?\\s*\\d*\\s*(?:minutes?|mins?|m)?)`, 'i');
                    const textContent = html.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ');
                    const match = textContent.match(pattern);
                    
                    return match ? cleanTimeText(match[1]) : '';
                }
            } catch (error) {
                debugLog(`Error in extractSpecificTime: ${error.message}`, 'warning');
            }
            
            return '';
        }

        function extractServings(doc, html) {
            if (!doc) return '';
            
            try {
                // Strategy 1: Common serving selectors
                const servingSelectors = [
                    '.recipe-yield',
                    '.serves',
                    '.servings',
                    '.recipe-servings',
                    '[class*="yield"]',
                    '[class*="serves"]',
                    '[class*="serving"]'
                ];
                
                for (const selector of servingSelectors) {
                    const element = doc.querySelector(selector);
                    if (element) {
                        const servingText = cleanServingText(element.textContent);
                        if (servingText) {
                            debugLog(`Found servings with selector ${selector}: ${servingText}`, 'success');
                            return servingText;
                        }
                    }
                }
                
                // Strategy 2: Look for serving patterns in text (only if html is provided)
                if (html && typeof html === 'string') {
                    const servingPatterns = [
                        /(?:serves?|servings?|yield|makes?):?\s*(\d+(?:-\d+)?(?:\s*(?:people|persons?|servings?))?)/i,
                        /(\d+)\s*(?:servings?|portions?|people)/i,
                        /serves?\s*(\d+(?:-\d+)?)/i
                    ];
                    
                    const textContent = html.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ');
                    
                    for (const pattern of servingPatterns) {
                        const match = textContent.match(pattern);
                        if (match) {
                            const servingText = cleanServingText(match[1]);
                            if (servingText) {
                                debugLog(`Found servings with pattern: ${servingText}`, 'success');
                                return servingText;
                            }
                        }
                    }
                }
            } catch (error) {
                debugLog(`Error in extractServings: ${error.message}`, 'warning');
            }
            
            return '';
        }

        function cleanTimeText(text) {
            if (!text || typeof text !== 'string') return '';
            
            try {
                // Remove extra whitespace and clean up
                let cleaned = text.trim().toLowerCase();
                
                // Convert common abbreviations to standard format
                cleaned = cleaned
                    .replace(/\bhrs?\b/g, 'h')
                    .replace(/\bmins?\b/g, 'm')
                    .replace(/\bminutes?\b/g, 'm')
                    .replace(/\bhours?\b/g, 'h');
                
                debugLog(`Cleaning time text: "${text}" -> "${cleaned}"`, 'info');
                
                // Strategy 1: Look for explicit hour and minute patterns
                const hourMinuteMatch = cleaned.match(/(\d+)\s*h[a-z]*\s*(\d+)\s*m/i);
                if (hourMinuteMatch) {
                    const hours = parseInt(hourMinuteMatch[1]);
                    const minutes = parseInt(hourMinuteMatch[2]);
                    debugLog(`Found hours + minutes: ${hours}h ${minutes}m`, 'success');
                    return `${hours}h ${minutes}m`;
                }
                
                // Strategy 2: Look for just hours
                const hoursOnlyMatch = cleaned.match(/(\d+)\s*h(?!\w)/i);
                if (hoursOnlyMatch) {
                    const hours = parseInt(hoursOnlyMatch[1]);
                    debugLog(`Found hours only: ${hours}h`, 'success');
                    return `${hours}h`;
                }
                
                // Strategy 3: Look for just minutes (this was the bug - treating all numbers as hours)
                const minutesOnlyMatch = cleaned.match(/(\d+)\s*m(?!\w)/i);
                if (minutesOnlyMatch) {
                    const minutes = parseInt(minutesOnlyMatch[1]);
                    debugLog(`Found minutes only: ${minutes}m`, 'success');
                    return `${minutes}m`;
                }
                
                // Strategy 4: Look for standalone numbers with context clues
                const numberMatch = cleaned.match(/(\d+)/);
                if (numberMatch) {
                    const number = parseInt(numberMatch[1]);
                    
                    // If the text contains "minute" or "min" context, treat as minutes
                    if (cleaned.includes('minute') || cleaned.includes('min')) {
                        debugLog(`Interpreting ${number} as minutes based on context`, 'success');
                        return `${number}m`;
                    }
                    
                    // If the text contains "hour" or "hr" context, treat as hours
                    if (cleaned.includes('hour') || cleaned.includes('hr')) {
                        debugLog(`Interpreting ${number} as hours based on context`, 'success');
                        return `${number}h`;
                    }
                    
                    // If number is very large (>180), likely minutes, otherwise could be either
                    if (number > 180) {
                        debugLog(`Large number ${number} interpreted as minutes`, 'success');
                        return `${number}m`;
                    } else if (number <= 5) {
                        debugLog(`Small number ${number} interpreted as hours`, 'success');
                        return `${number}h`;
                    } else {
                        // For medium numbers (6-180), default to minutes since most cooking times are in minutes
                        debugLog(`Medium number ${number} interpreted as minutes (default)`, 'success');
                        return `${number}m`;
                    }
                }
                
                debugLog(`Could not parse time from: "${text}"`, 'warning');
                return '';
                
            } catch (error) {
                debugLog(`Error in cleanTimeText: ${error.message}`, 'warning');
                return '';
            }
        }

        function cleanServingText(text) {
            if (!text || typeof text !== 'string') return '';
            
            try {
                // Extract just the number(s)
                const servingMatch = text.match(/(\d+(?:-\d+)?)/);
                if (servingMatch) {
                    return servingMatch[1];
                }
            } catch (error) {
                debugLog(`Error in cleanServingText: ${error.message}`, 'warning');
            }
            
            return '';
        }

        function addTimes(time1, time2) {
            if (!time1 || !time2 || typeof time1 !== 'string' || typeof time2 !== 'string') return '';
            
            try {
                // Simple time addition (basic implementation)
                const parseTime = (timeStr) => {
                    const hours = (timeStr.match(/(\d+)h/) || [0, 0])[1];
                    const minutes = (timeStr.match(/(\d+)m/) || [0, 0])[1];
                    return { h: parseInt(hours) || 0, m: parseInt(minutes) || 0 };
                };
                
                const t1 = parseTime(time1);
                const t2 = parseTime(time2);
                
                const totalMinutes = t1.m + t2.m;
                const totalHours = t1.h + t2.h + Math.floor(totalMinutes / 60);
                const remainingMinutes = totalMinutes % 60;
                
                if (totalHours > 0 && remainingMinutes > 0) {
                    return `${totalHours}h ${remainingMinutes}m`;
                } else if (totalHours > 0) {
                    return `${totalHours}h`;
                } else if (remainingMinutes > 0) {
                    return `${remainingMinutes}m`;
                }
            } catch (error) {
                debugLog(`Error in addTimes: ${error.message}`, 'warning');
            }
            
            return '';
        }

        function debugRecipeLoading() {
            console.log('=== RECIPE LOADING DEBUG ===');
            console.log('Current password:', currentPassword ? '***' + currentPassword.slice(-2) : 'none');
            console.log('Is session only:', isSessionOnly);
            console.log('Recipes in local array:', recipes.length);
            console.log('Recipe cards in DOM:', document.querySelectorAll('.recipe-card').length);
            
            console.log('\nLocal recipes array:');
            recipes.forEach((recipe, index) => {
                console.log(`${index + 1}. ID: "${recipe.id}" (${typeof recipe.id}) - Title: "${recipe.title}"`);
            });
            
            console.log('\nRecipe cards in DOM:');
            const cards = document.querySelectorAll('.recipe-card');
            cards.forEach((card, index) => {
                const onclick = card.getAttribute('onclick');
                const id = onclick ? onclick.match(/'([^']+)'/)?.[1] : 'unknown';
                console.log(`${index + 1}. DOM ID: "${id}" - Title: "${card.querySelector('.recipe-title')?.textContent}"`);
            });
            
            const isInSync = recipes.length === cards.length;
            console.log('\n✅ Arrays in sync:', isInSync);
            
            if (!isInSync) {
                console.log('❌ ISSUE: Local array and DOM are out of sync!');
                console.log('This means recipes were rendered but not stored in the local array.');
            }
            
            console.log('=== END DEBUG ===');
        }

        // Test function to manually trigger recipe loading
        async function testRecipeLoading() {
            if (!currentPassword) {
                console.log('❌ Please login with a password first');
                return;
            }
            
            console.log('🔄 Testing recipe loading...');
            
            try {
                const beforeCount = recipes.length;
                console.log('Recipes before reload:', beforeCount);
                
                await loadRecipes();
                
                const afterCount = recipes.length;
                console.log('Recipes after reload:', afterCount);
                
                if (afterCount === beforeCount) {
                    console.log('✅ Recipe count unchanged (expected if no new recipes)');
                } else {
                    console.log(`✅ Recipe count changed: ${beforeCount} -> ${afterCount}`);
                }
                
                debugRecipeLoading();
                
            } catch (error) {
                console.error('❌ Test failed:', error);
            }
        }

        // Open create recipe modal
        function openCreateModal() {
            if (createRecipeModal) {
                createRecipeModal.style.display = 'block';
                resetCreateForm();
                // Add initial ingredient and instruction fields
                addIngredientField();
                addInstructionField();
                // Focus on title field
                const titleField = document.getElementById('recipeTitle');
                if (titleField) {
                    setTimeout(() => titleField.focus(), 100);
                }
            }
        }

        // Close create recipe modal
        function closeCreateModal() {
            if (createRecipeModal) {
                createRecipeModal.style.display = 'none';
                resetCreateForm();
            }
        }

        // Reset the create form
        function resetCreateForm() {
            const form = document.getElementById('createRecipeForm');
            if (form) {
                form.reset();
            }
            
            // Clear dynamic lists
            const ingredientsList = document.getElementById('ingredientsList');
            const instructionsList = document.getElementById('instructionsList');
            
            if (ingredientsList) ingredientsList.innerHTML = '';
            if (instructionsList) instructionsList.innerHTML = '';
            
            ingredientCount = 0;
            instructionCount = 0;
        }

        // Add ingredient field
        function addIngredientField(value = '') {
            const ingredientsList = document.getElementById('ingredientsList');
            if (!ingredientsList) return;
            
            ingredientCount++;
            
            const ingredientDiv = document.createElement('div');
            ingredientDiv.className = 'dynamic-item';
            ingredientDiv.setAttribute('data-ingredient-id', ingredientCount);
            
            ingredientDiv.innerHTML = `
                <div class="dynamic-item-number">${getIngredientNumber()}</div>
                <input type="text" class="dynamic-input" value="${escapeHtml(value)}" placeholder="Enter ingredient (e.g., 1 cup flour)" required>
                <div class="dynamic-controls">
                    <button type="button" onclick="moveIngredientUp(this)" class="dynamic-btn move-up-btn" title="Move Up">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                    <button type="button" onclick="moveIngredientDown(this)" class="dynamic-btn move-down-btn" title="Move Down">
                        <i class="fas fa-arrow-down"></i>
                    </button>
                    <button type="button" onclick="removeIngredientField(this)" class="dynamic-btn remove-item-btn" title="Remove">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            
            ingredientsList.appendChild(ingredientDiv);
            updateIngredientNumbers();
        }

        // Add instruction field
        function addInstructionField(value = '') {
            const instructionsList = document.getElementById('instructionsList');
            if (!instructionsList) return;
            
            instructionCount++;
            
            const instructionDiv = document.createElement('div');
            instructionDiv.className = 'dynamic-item';
            instructionDiv.setAttribute('data-instruction-id', instructionCount);
            
            instructionDiv.innerHTML = `
                <div class="dynamic-item-number">${getInstructionNumber()}</div>
                <textarea class="dynamic-textarea" placeholder="Enter instruction step" required>${escapeHtml(value)}</textarea>
                <div class="dynamic-controls">
                    <button type="button" onclick="moveInstructionUp(this)" class="dynamic-btn move-up-btn" title="Move Up">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                    <button type="button" onclick="moveInstructionDown(this)" class="dynamic-btn move-down-btn" title="Move Down">
                        <i class="fas fa-arrow-down"></i>
                    </button>
                    <button type="button" onclick="removeInstructionField(this)" class="dynamic-btn remove-item-btn" title="Remove">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            
            instructionsList.appendChild(instructionDiv);
            updateInstructionNumbers();
        }

        // Remove ingredient field
        function removeIngredientField(button) {
            const ingredientItem = button.closest('.dynamic-item');
            const ingredientsList = document.getElementById('ingredientsList');
            
            if (ingredientsList && ingredientsList.children.length > 1) {
                ingredientItem.remove();
                updateIngredientNumbers();
            }
        }

        // Remove instruction field
        function removeInstructionField(button) {
            const instructionItem = button.closest('.dynamic-item');
            const instructionsList = document.getElementById('instructionsList');
            
            if (instructionsList && instructionsList.children.length > 1) {
                instructionItem.remove();
                updateInstructionNumbers();
            }
        }

        // Move ingredient up
        function moveIngredientUp(button) {
            const item = button.closest('.dynamic-item');
            const prevItem = item.previousElementSibling;
            if (prevItem) {
                item.parentNode.insertBefore(item, prevItem);
                updateIngredientNumbers();
            }
        }

        // Move ingredient down
        function moveIngredientDown(button) {
            const item = button.closest('.dynamic-item');
            const nextItem = item.nextElementSibling;
            if (nextItem) {
                item.parentNode.insertBefore(nextItem, item);
                updateIngredientNumbers();
            }
        }

        // Move instruction up
        function moveInstructionUp(button) {
            const item = button.closest('.dynamic-item');
            const prevItem = item.previousElementSibling;
            if (prevItem) {
                item.parentNode.insertBefore(item, prevItem);
                updateInstructionNumbers();
            }
        }

        // Move instruction down
        function moveInstructionDown(button) {
            const item = button.closest('.dynamic-item');
            const nextItem = item.nextElementSibling;
            if (nextItem) {
                item.parentNode.insertBefore(nextItem, item);
                updateInstructionNumbers();
            }
        }

        // Update ingredient numbers
        function updateIngredientNumbers() {
            const ingredientsList = document.getElementById('ingredientsList');
            if (!ingredientsList) return;
            
            const items = ingredientsList.querySelectorAll('.dynamic-item');
            items.forEach((item, index) => {
                const numberDiv = item.querySelector('.dynamic-item-number');
                if (numberDiv) {
                    numberDiv.textContent = index + 1;
                }
            });
        }

        // Update instruction numbers
        function updateInstructionNumbers() {
            const instructionsList = document.getElementById('instructionsList');
            if (!instructionsList) return;
            
            const items = instructionsList.querySelectorAll('.dynamic-item');
            items.forEach((item, index) => {
                const numberDiv = item.querySelector('.dynamic-item-number');
                if (numberDiv) {
                    numberDiv.textContent = index + 1;
                }
            });
        }

        // Get next ingredient number
        function getIngredientNumber() {
            const ingredientsList = document.getElementById('ingredientsList');
            return ingredientsList ? ingredientsList.children.length + 1 : 1;
        }

        // Get next instruction number
        function getInstructionNumber() {
            const instructionsList = document.getElementById('instructionsList');
            return instructionsList ? instructionsList.children.length + 1 : 1;
        }

        // Save manual recipe
        async function saveManualRecipe() {
            try {
                // Collect form data
                const title = document.getElementById('recipeTitle').value.trim();
                const description = document.getElementById('recipeDescription').value.trim();
                const image = document.getElementById('recipeImage').value.trim();
                const prepTime = document.getElementById('recipePrepTime').value.trim();
                const cookTime = document.getElementById('recipeCookTime').value.trim();
                const totalTime = document.getElementById('recipeTotalTime').value.trim();
                const servings = document.getElementById('recipeServings').value.trim();
                
                // Validate required fields
                if (!title) {
                    showMessage('Please enter a recipe title', 'error');
                    return;
                }
                
                // Collect ingredients
                const ingredientInputs = document.querySelectorAll('#ingredientsList .dynamic-input');
                const ingredients = Array.from(ingredientInputs)
                    .map(input => input.value.trim())
                    .filter(value => value.length > 0);
                
                if (ingredients.length === 0) {
                    showMessage('Please add at least one ingredient', 'error');
                    return;
                }
                
                // Collect instructions
                const instructionInputs = document.querySelectorAll('#instructionsList .dynamic-textarea');
                const instructions = Array.from(instructionInputs)
                    .map(input => input.value.trim())
                    .filter(value => value.length > 0);
                
                if (instructions.length === 0) {
                    showMessage('Please add at least one instruction', 'error');
                    return;
                }
                
                // Create recipe object
                const recipeData = {
                    id: Date.now().toString(),
                    title: title,
                    description: description,
                    image: image,
                    ingredients: ingredients,
                    instructions: instructions,
                    prepTime: prepTime,
                    cookTime: cookTime,
                    totalTime: totalTime,
                    servings: servings,
                    url: '', // Manual recipes don't have source URLs
                    dateAdded: new Date().toISOString()
                };
                
                // Show saving indicator
                showSavingIndicator();
                
                // Save recipe
                if (isSessionOnly) {
                    // Session-only mode: just add to local array
                    recipes.push(recipeData);
                    showMessage('Recipe created in session (not saved permanently)', 'success');
                } else {
                    // Cloud mode: save to Google Sheets
                    await saveRecipeToSheet(recipeData);
                    recipes.push(recipeData);
                    showMessage('Recipe created and saved to cloud successfully!', 'success');
                }
                
                // Update UI
                renderRecipes();
                closeCreateModal();
                hideSavingIndicator();
                
            } catch (error) {
                hideSavingIndicator();
                console.error('Failed to save manual recipe:', error);
                showMessage('Failed to save recipe: ' + error.message, 'error');
            }
        }

        // Open shopping list flow
        function openShoppingListFlow() {
            const savedList = localStorage.getItem('shoppingList');
            if (savedList) {
                // Show existing shopping list
                loadShoppingList();
                openShoppingListModal();
            } else {
                // Start recipe selection
                openRecipeSelectionModal();
            }
        }

        // Open recipe selection modal
        function openRecipeSelectionModal() {
            if (recipeSelectionModal) {
                recipeSelectionModal.style.display = 'block';
                populateRecipeSelection();
            }
        }

        // Close recipe selection modal
        function closeRecipeSelectionModal() {
            if (recipeSelectionModal) {
                recipeSelectionModal.style.display = 'none';
                selectedRecipes = [];
                isAddingMoreRecipes = false;
            }
        }

        // Open shopping list modal
        function openShoppingListModal() {
            if (shoppingListModal) {
                shoppingListModal.style.display = 'block';
                renderShoppingList();
            }
        }

        // Close shopping list modal
        function closeShoppingListModal() {
            if (shoppingListModal) {
                shoppingListModal.style.display = 'none';
            }
        }

        // Populate recipe selection
        function populateRecipeSelection() {
            const recipeCheckboxList = document.getElementById('recipeCheckboxList');
            if (!recipeCheckboxList) return;
            
            if (recipes.length === 0) {
                recipeCheckboxList.innerHTML = '<p>No recipes available. Please add some recipes first.</p>';
                return;
            }
            
            const checkboxesHTML = recipes.map(recipe => {
                const isSelected = selectedRecipes.some(sr => sr.recipeId === recipe.id);
                const currentQuantity = selectedRecipes.find(sr => sr.recipeId === recipe.id)?.quantity || 1;
                
                return `
                    <div class="recipe-checkbox-item ${isSelected ? 'selected' : ''}" data-recipe-id="${recipe.id}">
                        <input type="checkbox" class="recipe-checkbox" ${isSelected ? 'checked' : ''} 
                            onchange="toggleRecipeSelection('${recipe.id}', this.checked)">
                        <div class="recipe-info-select">
                            <div class="recipe-title-select">${recipe.title}</div>
                            <div class="recipe-meta-select">
                                ${recipe.ingredients.length} ingredients • ${recipe.instructions.length} steps
                            </div>
                        </div>
                        <div>
                            <input type="number" class="quantity-input" min="1" max="10" value="${currentQuantity}" 
                                onchange="updateRecipeQuantity('${recipe.id}', this.value)">
                            <span class="quantity-label">servings</span>
                        </div>
                    </div>
                `;
            }).join('');
            
            recipeCheckboxList.innerHTML = checkboxesHTML;
        }

        // Toggle recipe selection
        function toggleRecipeSelection(recipeId, isChecked) {
            const item = document.querySelector(`[data-recipe-id="${recipeId}"]`);
            
            if (isChecked) {
                const quantityInput = item.querySelector('.quantity-input');
                const quantity = parseInt(quantityInput.value) || 1;
                
                selectedRecipes.push({ recipeId, quantity });
                item.classList.add('selected');
            } else {
                selectedRecipes = selectedRecipes.filter(sr => sr.recipeId !== recipeId);
                item.classList.remove('selected');
            }
        }

        // Update recipe quantity
        function updateRecipeQuantity(recipeId, newQuantity) {
            const quantity = parseInt(newQuantity) || 1;
            const selectedRecipe = selectedRecipes.find(sr => sr.recipeId === recipeId);
            
            if (selectedRecipe) {
                selectedRecipe.quantity = quantity;
            }
        }

        // Generate shopping list
        function generateShoppingList() {
            if (selectedRecipes.length === 0) {
                showMessage('Please select at least one recipe', 'error');
                return;
            }
            
            // Combine ingredients from all selected recipes
            const combinedIngredients = [];
            
            selectedRecipes.forEach(({ recipeId, quantity }) => {
                const recipe = recipes.find(r => r.id === recipeId);
                if (recipe) {
                    recipe.ingredients.forEach(ingredient => {
                        // Scale ingredient by quantity if needed
                        let scaledIngredient = ingredient;
                        if (quantity > 1) {
                            scaledIngredient = scaleIngredient(ingredient, quantity);
                        }
                        combinedIngredients.push(scaledIngredient);
                    });
                }
            });
            
            // Remove duplicates and create shopping list items
            const uniqueIngredients = [...new Set(combinedIngredients)];
            
            if (isAddingMoreRecipes) {
                // Add to existing shopping list
                uniqueIngredients.forEach(ingredient => {
                    const exists = shoppingListItems.some(item => item.ingredient === ingredient);
                    if (!exists) {
                        shoppingListItems.push({
                            id: 'item_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9), // Better ID generation
                            ingredient,
                            checked: false
                        });
                    }
                });
            } else {
                // Create new shopping list
                shoppingListItems = uniqueIngredients.map(ingredient => ({
                    id: 'item_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9), // Better ID generation
                    ingredient,
                    checked: false
                }));
            }
            
            // Save to localStorage immediately
            saveShoppingList();
            console.log('Shopping list generated and saved:', shoppingListItems); // Debug log
            
            // Close recipe selection and open shopping list
            closeRecipeSelectionModal();
            openShoppingListModal();
            
            showMessage(isAddingMoreRecipes ? 'Recipes added to shopping list!' : 'Shopping list generated!', 'success');
        }

        function debugShoppingList() {
            console.log('=== SHOPPING LIST DEBUG ===');
            console.log('Current shoppingListItems:', shoppingListItems);
            console.log('localStorage content:', localStorage.getItem('shoppingList'));
            
            if (localStorage.getItem('shoppingList')) {
                try {
                    const parsed = JSON.parse(localStorage.getItem('shoppingList'));
                    console.log('Parsed localStorage:', parsed);
                } catch (e) {
                    console.error('Error parsing localStorage:', e);
                }
            }
            console.log('=== END DEBUG ===');
        }

        // Scale ingredient by quantity (basic implementation)
        function scaleIngredient(ingredient, quantity) {
            // Simple scaling - just add quantity prefix for most ingredients
            const numberMatch = ingredient.match(/^(\d+(?:\.\d+)?(?:\/\d+)?)\s*(.+)/);
            if (numberMatch) {
                const originalAmount = parseFloat(numberMatch[1]);
                const scaledAmount = originalAmount * quantity;
                return `${scaledAmount} ${numberMatch[2]}`;
            }
            
            // If no number found, just indicate multiple servings
            return quantity > 1 ? `${ingredient} (x${quantity})` : ingredient;
        }

        // Render shopping list
        function renderShoppingList() {
            const shoppingListItemsDiv = document.getElementById('shoppingListItems');
            const shoppingStats = document.getElementById('shoppingStats');
            
            if (!shoppingListItemsDiv || !shoppingStats) return;
            
            if (shoppingListItems.length === 0) {
                shoppingListItemsDiv.innerHTML = '<p>Your shopping list is empty. Add some recipes to get started!</p>';
                shoppingStats.innerHTML = '';
                return;
            }
            
            // Render items with better ID handling
            const itemsHTML = shoppingListItems.map(item => `
                <div class="shopping-item ${item.checked ? 'checked' : ''}">
                    <input type="checkbox" class="shopping-checkbox" ${item.checked ? 'checked' : ''} 
                        onchange="toggleShoppingItem('${item.id}')" data-item-id="${item.id}">
                    <span class="shopping-item-text">${escapeHtml(item.ingredient)}</span>
                    <button class="remove-item-btn" onclick="removeShoppingItem('${item.id}')" title="Remove">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `).join('');
            
            shoppingListItemsDiv.innerHTML = itemsHTML;
            
            // Update stats
            const total = shoppingListItems.length;
            const completed = shoppingListItems.filter(item => item.checked).length;
            const remaining = total - completed;
            
            shoppingStats.innerHTML = `
                <strong>${total}</strong> items total • 
                <strong>${completed}</strong> completed • 
                <strong>${remaining}</strong> remaining
            `;
        }

        // Toggle shopping item checked state
        function toggleShoppingItem(itemId) {
            console.log('Toggling item:', itemId); // Debug log
            
            const item = shoppingListItems.find(i => i.id == itemId); // Use == instead of === for ID comparison
            if (item) {
                item.checked = !item.checked;
                console.log('Item checked state:', item.checked); // Debug log
                
                // Save immediately
                saveShoppingList();
                
                // Re-render the list
                renderShoppingList();
                
                console.log('Shopping list saved to localStorage'); // Debug log
            } else {
                console.error('Item not found:', itemId);
            }
        }

        // Remove shopping item
        function removeShoppingItem(itemId) {
            shoppingListItems = shoppingListItems.filter(i => i.id !== itemId);
            saveShoppingList();
            renderShoppingList();
        }

        // Open add more recipes flow
        function openAddMoreRecipes() {
            isAddingMoreRecipes = true;
            selectedRecipes = []; // Reset selection
            closeShoppingListModal();
            openRecipeSelectionModal();
        }

        // Clear shopping list
        function clearShoppingList() {
            if (confirm('Are you sure you want to clear your shopping list?')) {
                shoppingListItems = [];
                localStorage.removeItem('shoppingList');
                renderShoppingList();
                showMessage('Shopping list cleared', 'success');
            }
        }

        // Save shopping list to localStorage
        function saveShoppingList() {
            localStorage.setItem('shoppingList', JSON.stringify({
                items: shoppingListItems,
                lastUpdated: new Date().toISOString()
            }));
        }

        // Load shopping list from localStorage
        function loadShoppingList() {
            const saved = localStorage.getItem('shoppingList');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    shoppingListItems = data.items || [];
                } catch (error) {
                    console.error('Error loading shopping list:', error);
                    shoppingListItems = [];
                }
            }
        }
    </script>
</body>
</html>